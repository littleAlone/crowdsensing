{"ast":null,"code":"import _typeof from \"F:/python/course/crowdsensing/frontend/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _toConsumableArray from \"F:/python/course/crowdsensing/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/web.timers.js\";\nexport default {\n  name: 'SimulationCanvas',\n  props: {\n    hunters: {\n      type: Array,\n      required: true\n    },\n    targets: {\n      type: Array,\n      required: true\n    },\n    environmentSize: {\n      type: Number,\n      \"default\": 500\n    },\n    isRunning: {\n      type: Boolean,\n      \"default\": false\n    },\n    isCaptured: {\n      type: Boolean,\n      \"default\": false\n    },\n    escaped: {\n      type: Boolean,\n      \"default\": false\n    },\n    showTrails: {\n      type: Boolean,\n      \"default\": true\n    },\n    showVisionRange: {\n      type: Boolean,\n      \"default\": false\n    },\n    showCommunicationRange: {\n      type: Boolean,\n      \"default\": false\n    },\n    obstacles: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      } // 确保默认为空数组\n    }\n  },\n  data: function data() {\n    return {\n      canvasSize: 600,\n      canvas: null,\n      ctx: null,\n      scale: 1,\n      colorMap: {\n        hunter: '#3949AB',\n        // 更深的蓝色\n        target: '#e53935',\n        // 更鲜艳的红色\n        vision: 'rgba(57, 73, 171, 0.1)',\n        // 半透明蓝色\n        communication: 'rgba(57, 73, 171, 0.05)',\n        // 更透明的蓝色\n        trail: 'rgba(57, 73, 171, 0.4)',\n        // 半透明蓝色\n        captureRange: 'rgba(76, 175, 80, 0.4)',\n        // 更明显的绿色\n        captured: 'rgba(244, 67, 54, 0.25)',\n        // 半透明红色\n        obstacle: 'rgba(100, 100, 110, 0.8)' // 障碍物颜色\n      },\n      // 跟踪之前的位置，用于优化渲染\n      previousPositions: {\n        hunters: [],\n        targets: []\n      },\n      // 本地obstacles引用，防止未定义错误\n      localObstacles: Array.isArray(this.obstacles) ? _toConsumableArray(this.obstacles) : [],\n      showObstacles: true,\n      // 默认显示障碍物\n      // 防抖渲染计时器\n      renderTimer: null,\n      // 帧率控制\n      lastRenderTime: 0,\n      targetFPS: 30,\n      // 渲染计数，用于降低非必要渲染的频率\n      renderCount: 0,\n      // 动画相关\n      animationFrameId: null,\n      animationFrames: 0,\n      pulseDirection: 1,\n      pulseState: 0,\n      floatOffset: 0,\n      // 是否显示标签\n      showLabels: false,\n      // 记录前一次运行状态\n      previousIsRunning: false,\n      previousIsCaptured: false,\n      previousEscaped: false,\n      // 新增：需要重新渲染标志\n      needsRender: false,\n      // 最后一次渲染状态\n      lastRenderState: {\n        isCaptured: false,\n        isEscaped: false\n      },\n      // 缓存数据\n      huntersCache: null,\n      targetsCache: null\n    };\n  },\n  mounted: function mounted() {\n    this.initCanvas();\n    // 初始化本地obstacles\n    this.localObstacles = Array.isArray(this.obstacles) ? _toConsumableArray(this.obstacles) : [];\n    this.drawSimulation();\n\n    // 添加窗口大小变化监听\n    window.addEventListener('resize', this.handleResize);\n\n    // 使用requestAnimationFrame实现高效渲染循环\n    this.startRenderLoop();\n  },\n  beforeDestroy: function beforeDestroy() {\n    // 清理事件监听器\n    window.removeEventListener('resize', this.handleResize);\n\n    // 停止渲染循环\n    this.stopRenderLoop();\n\n    // 清理计时器\n    if (this.renderTimer) {\n      clearTimeout(this.renderTimer);\n    }\n\n    // 清理缓存\n    this.huntersCache = null;\n    this.targetsCache = null;\n  },\n  methods: {\n    // 初始化画布\n    initCanvas: function initCanvas() {\n      this.canvas = this.$refs.canvas;\n      this.ctx = this.canvas.getContext('2d');\n      this.scale = this.canvasSize / this.environmentSize;\n\n      // 初始化previousPositions\n      this.updatePreviousPositions();\n    },\n    // 处理窗口大小变化\n    handleResize: function handleResize() {\n      var _this = this;\n      // 防抖处理\n      if (this.renderTimer) {\n        clearTimeout(this.renderTimer);\n      }\n      this.renderTimer = setTimeout(function () {\n        // 重新计算画布大小（可选，如果需要响应式调整画布大小）\n        // this.canvasSize = Math.min(window.innerWidth * 0.7, 600);\n        _this.scale = _this.canvasSize / _this.environmentSize;\n        _this.needsRender = true;\n        _this.drawSimulation(true); // 强制完全重绘\n      }, 200);\n    },\n    // 启动渲染循环\n    startRenderLoop: function startRenderLoop() {\n      if (!this.animationFrameId) {\n        this.lastRenderTime = performance.now();\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\n      }\n    },\n    // 停止渲染循环\n    stopRenderLoop: function stopRenderLoop() {\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n    },\n    // 渲染循环\n    renderLoop: function renderLoop(timestamp) {\n      var _this2 = this;\n      try {\n        // 判断模拟状态是否变化\n        var stateChanged = this.isCaptured !== this.lastRenderState.isCaptured || this.escaped !== this.lastRenderState.isEscaped;\n\n        // 如果模拟已结束且状态未变化，减少渲染频率\n        if ((this.isCaptured || this.escaped) && !stateChanged && !this.needsRender) {\n          // 模拟已结束，使用低频率更新\n          setTimeout(function () {\n            _this2.animationFrameId = requestAnimationFrame(_this2.renderLoop);\n          }, 1000); // 降低为每秒一帧\n          return;\n        }\n\n        // 更新最后渲染状态\n        if (stateChanged) {\n          this.lastRenderState.isCaptured = this.isCaptured;\n          this.lastRenderState.isEscaped = this.escaped;\n          this.needsRender = true;\n        }\n\n        // 正常渲染逻辑\n        var elapsed = timestamp - this.lastRenderTime;\n        var frameTime = 1000 / this.targetFPS;\n        if (elapsed >= frameTime || this.needsRender) {\n          this.lastRenderTime = timestamp;\n\n          // 更新动画状态\n          this.updateAnimationState();\n\n          // 仅在需要时渲染\n          if (this.needsRender || this.isRunning || this.animationFrames % 15 === 0) {\n            this.drawOptimizedSimulation();\n            this.needsRender = false;\n          }\n        }\n\n        // 设置下一帧\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\n      } catch (error) {\n        console.error('渲染循环错误:', error);\n        // 错误恢复：停止当前循环，稍后重试\n        if (this.animationFrameId) {\n          cancelAnimationFrame(this.animationFrameId);\n          this.animationFrameId = null;\n        }\n\n        // 延迟后尝试重启循环\n        setTimeout(function () {\n          _this2.startRenderLoop();\n        }, 2000);\n      }\n    },\n    // 更新动画状态\n    updateAnimationState: function updateAnimationState() {\n      this.animationFrames++;\n      if (this.animationFrames % 3 === 0) {\n        // 更新脉冲效果\n        this.pulseState += 0.05 * this.pulseDirection;\n        if (this.pulseState >= 1) {\n          this.pulseState = 1;\n          this.pulseDirection = -1;\n        } else if (this.pulseState <= 0) {\n          this.pulseState = 0;\n          this.pulseDirection = 1;\n        }\n\n        // 更新浮动效果\n        this.floatOffset += 0.1;\n      }\n    },\n    // 处理hunters数据\n    ensureHuntersArray: function ensureHuntersArray() {\n      // 如果模拟已完成且有缓存，使用缓存\n      if ((this.isCaptured || this.escaped) && this.huntersCache) {\n        return this.huntersCache;\n      }\n\n      // 正常处理逻辑\n      var result = [];\n      if (typeof this.hunters === 'string') {\n        try {\n          result = JSON.parse(this.hunters);\n        } catch (e) {\n          console.error('无法解析hunters数据:', e);\n        }\n      } else if (Array.isArray(this.hunters)) {\n        result = _toConsumableArray(this.hunters); // 创建浅拷贝以避免直接操作原始数据\n      }\n\n      // 如果模拟已完成，缓存结果\n      if (this.isCaptured || this.escaped) {\n        this.huntersCache = result;\n      }\n      return result;\n    },\n    // 处理targets数据\n    ensureTargetsArray: function ensureTargetsArray() {\n      // 如果模拟已完成且有缓存，使用缓存\n      if ((this.isCaptured || this.escaped) && this.targetsCache) {\n        return this.targetsCache;\n      }\n\n      // 正常处理逻辑\n      var result = [];\n      if (typeof this.targets === 'string') {\n        try {\n          result = JSON.parse(this.targets);\n        } catch (e) {\n          console.error('无法解析targets数据:', e);\n        }\n      } else if (Array.isArray(this.targets)) {\n        result = _toConsumableArray(this.targets); // 创建浅拷贝以避免直接操作原始数据\n      }\n\n      // 如果模拟已完成，缓存结果\n      if (this.isCaptured || this.escaped) {\n        this.targetsCache = result;\n      }\n      return result;\n    },\n    // 检查位置是否有变化\n    hasPositionsChanged: function hasPositionsChanged() {\n      // 优化：快速检查数组长度变化\n      if (this.hunters.length !== this.previousPositions.hunters.length || this.targets.length !== this.previousPositions.targets.length) {\n        return true;\n      }\n\n      // 检查运行状态变化\n      if (this.isRunning !== this.previousIsRunning || this.isCaptured !== this.previousIsCaptured || this.escaped !== this.previousEscaped) {\n        this.previousIsRunning = this.isRunning;\n        this.previousIsCaptured = this.isCaptured;\n        this.previousEscaped = this.escaped;\n        return true;\n      }\n\n      // 渲染计数，每5帧强制完全重绘一次（避免累积误差）\n      this.renderCount++;\n      if (this.renderCount >= 5) {\n        this.renderCount = 0;\n        return true;\n      }\n\n      // 只有在运行中或首次渲染时，才进行位置变化检查\n      if (!this.isRunning && this.previousPositions.hunters.length > 0) {\n        return false;\n      }\n\n      // 智能体位置变化检测\n      var threshold = 0.5; // 位置变化阈值\n\n      // 确保数据格式正确\n      var huntersArray = this.ensureHuntersArray();\n      var targetsArray = this.ensureTargetsArray();\n\n      // 检查猎手位置变化\n      for (var i = 0; i < huntersArray.length; i++) {\n        var hunter = huntersArray[i];\n        var prevHunter = this.previousPositions.hunters[i];\n        if (!prevHunter || !hunter) return true;\n        if (!Array.isArray(hunter.position) || !Array.isArray(prevHunter.position)) return true;\n        if (Math.abs(hunter.position[0] - prevHunter.position[0]) > threshold || Math.abs(hunter.position[1] - prevHunter.position[1]) > threshold) {\n          return true;\n        }\n      }\n\n      // 检查目标位置变化\n      for (var _i = 0; _i < targetsArray.length; _i++) {\n        var target = targetsArray[_i];\n        var prevTarget = this.previousPositions.targets[_i];\n        if (!prevTarget || !target) return true;\n        if (!Array.isArray(target.position) || !Array.isArray(prevTarget.position)) return true;\n        if (Math.abs(target.position[0] - prevTarget.position[0]) > threshold || Math.abs(target.position[1] - prevTarget.position[1]) > threshold) {\n          return true;\n        }\n      }\n      return false;\n    },\n    // 更新之前的位置\n    updatePreviousPositions: function updatePreviousPositions() {\n      // 确保数据格式正确\n      var huntersArray = this.ensureHuntersArray();\n      var targetsArray = this.ensureTargetsArray();\n\n      // 深拷贝位置数据，确保防御性检查\n      this.previousPositions.hunters = huntersArray.map(function (hunter) {\n        if (hunter && Array.isArray(hunter.position)) {\n          return {\n            id: hunter.id,\n            position: _toConsumableArray(hunter.position)\n          };\n        }\n        return {\n          id: -1,\n          position: [0, 0]\n        }; // 默认值，防止错误\n      });\n      this.previousPositions.targets = targetsArray.map(function (target) {\n        if (target && Array.isArray(target.position)) {\n          return {\n            id: target.id,\n            position: _toConsumableArray(target.position)\n          };\n        }\n        return {\n          id: -1,\n          position: [0, 0]\n        }; // 默认值，防止错误\n      });\n    },\n    // 优化的绘制方法\n    drawOptimizedSimulation: function drawOptimizedSimulation() {\n      if (!this.ctx) return;\n      try {\n        // 清除画布\n        this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\n        this.drawBackground();\n\n        // 绘制环境边界\n        this.ctx.strokeStyle = '#ccc';\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\n\n        // 绘制障碍物 - 只在必要时绘制\n        if (this.obstacles && Array.isArray(this.obstacles) && this.obstacles.length > 0 && this.showObstacles) {\n          this.drawObstacles();\n        }\n\n        // 绘制捕获或逃脱状态\n        if (this.isCaptured) {\n          this.ctx.fillStyle = this.colorMap.captured;\n          this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n        } else if (this.escaped) {\n          this.ctx.fillStyle = 'rgba(255, 248, 225, 0.5)'; // 逃脱背景色\n          this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n        }\n\n        // 绘制轨迹\n        if (this.showTrails) {\n          this.drawTrails();\n        }\n\n        // 绘制视野和通信范围\n        if (this.showVisionRange || this.showCommunicationRange) {\n          this.drawRanges();\n        }\n\n        // 获取处理后的数据\n        var huntersArray = this.ensureHuntersArray();\n        var targetsArray = this.ensureTargetsArray();\n\n        // 使用安全的方式绘制猎手\n        if (Array.isArray(huntersArray)) {\n          for (var i = 0; i < huntersArray.length; i++) {\n            var hunter = huntersArray[i];\n            if (hunter && Array.isArray(hunter.position)) {\n              this.drawAgent(hunter, 'hunter');\n            }\n          }\n        }\n\n        // 使用安全的方式绘制目标\n        if (Array.isArray(targetsArray)) {\n          for (var _i2 = 0; _i2 < targetsArray.length; _i2++) {\n            var target = targetsArray[_i2];\n            if (target && Array.isArray(target.position)) {\n              this.drawAgent(target, 'target');\n            }\n          }\n        }\n\n        // 更新位置缓存，用于下次渲染比较\n        if (!this.isCaptured && !this.escaped) {\n          this.updatePreviousPositions();\n        }\n      } catch (error) {\n        console.error('绘制模拟时出错:', error);\n        // 不中断渲染循环\n      }\n    },\n    // 绘制障碍物\n    drawObstacles: function drawObstacles() {\n      var obstaclesToRender = null;\n\n      // 首先检查本地障碍物数组\n      if (Array.isArray(this.localObstacles) && this.localObstacles.length > 0) {\n        obstaclesToRender = this.localObstacles;\n      }\n      // 然后检查props障碍物数组\n      else if (Array.isArray(this.obstacles) && this.obstacles.length > 0) {\n        obstaclesToRender = this.obstacles;\n        // 同步更新本地数据\n        this.localObstacles = _toConsumableArray(this.obstacles);\n      } else {\n        return;\n      }\n\n      // 遍历绘制每个障碍物\n      for (var i = 0; i < obstaclesToRender.length; i++) {\n        var obstacle = obstaclesToRender[i];\n\n        // 检查障碍物数据完整性\n        if (!obstacle) {\n          continue;\n        }\n\n        // 确保position数据存在并格式正确\n        var position = obstacle.position;\n        if (!position) {\n          continue;\n        }\n\n        // 处理position可能的不同格式\n        var pos = void 0;\n        try {\n          if (Array.isArray(position)) {\n            pos = this.transformPosition(position);\n          } else if (_typeof(position) === 'object') {\n            // 对象格式 {x, y}\n            if ('x' in position && 'y' in position) {\n              pos = {\n                x: position.x * this.scale,\n                y: position.y * this.scale\n              };\n            } else {\n              continue;\n            }\n          } else {\n            continue;\n          }\n        } catch (e) {\n          console.error(\"\\u5904\\u7406\\u969C\\u788D\\u7269[\".concat(i, \"]\\u4F4D\\u7F6E\\u65F6\\u51FA\\u9519:\"), e);\n          continue;\n        }\n\n        // 获取并检查半径\n        var radius = obstacle.radius * this.scale;\n        if (!radius || isNaN(radius) || radius <= 0) {\n          continue;\n        }\n\n        // 绘制障碍物\n        try {\n          // 设置样式\n          this.ctx.fillStyle = 'rgba(100, 100, 110, 0.8)';\n          this.ctx.strokeStyle = 'rgba(80, 80, 90, 0.9)';\n          this.ctx.lineWidth = 2;\n\n          // 绘制圆形\n          this.ctx.beginPath();\n          this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\n          this.ctx.fill();\n          this.ctx.stroke();\n\n          // 添加编号标签（便于调试）\n          this.ctx.fillStyle = 'white';\n          this.ctx.font = '12px Arial';\n          this.ctx.textAlign = 'center';\n          this.ctx.textBaseline = 'middle';\n          this.ctx.fillText(\"\".concat(i), pos.x, pos.y);\n        } catch (e) {\n          console.error(\"\\u7ED8\\u5236\\u969C\\u788D\\u7269[\".concat(i, \"]\\u65F6\\u51FA\\u9519:\"), e);\n        }\n      }\n    },\n    drawBackground: function drawBackground() {\n      var gridSize = 25 * this.scale;\n      var width = this.canvasSize;\n      var height = this.canvasSize;\n\n      // 填充背景色\n      this.ctx.fillStyle = '#f5f7fa';\n      this.ctx.fillRect(0, 0, width, height);\n      this.ctx.strokeStyle = 'rgba(200, 200, 220, 0.3)';\n      this.ctx.lineWidth = 1;\n\n      // 绘制网格线\n      for (var x = 0; x <= width; x += gridSize) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(x, 0);\n        this.ctx.lineTo(x, height);\n        this.ctx.stroke();\n      }\n      for (var y = 0; y <= height; y += gridSize) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(0, y);\n        this.ctx.lineTo(width, y);\n        this.ctx.stroke();\n      }\n\n      // 添加坐标轴\n      this.ctx.strokeStyle = 'rgba(150, 150, 180, 0.4)';\n      this.ctx.lineWidth = 2;\n\n      // x轴\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, height / 2);\n      this.ctx.lineTo(width, height / 2);\n      this.ctx.stroke();\n\n      // y轴\n      this.ctx.beginPath();\n      this.ctx.moveTo(width / 2, 0);\n      this.ctx.lineTo(width / 2, height);\n      this.ctx.stroke();\n    },\n    // 完整重绘方法\n    drawSimulation: function drawSimulation() {\n      var forceFullRedraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (!this.ctx) return;\n\n      // 如果不需要强制重绘，使用优化版本\n      if (!forceFullRedraw && this.previousPositions.hunters.length > 0) {\n        return this.drawOptimizedSimulation();\n      }\n\n      // 设置完全重绘所需的标记\n      this.needsRender = true;\n\n      // 清除画布\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\n      this.drawBackground();\n\n      // 绘制环境边界\n      this.ctx.strokeStyle = '#ccc';\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\n\n      // 绘制障碍物 - 添加防御性检查\n      if (this.obstacles && Array.isArray(this.obstacles) && this.obstacles.length > 0 && this.showObstacles) {\n        this.drawObstacles();\n      }\n\n      // 绘制捕获状态\n      if (this.isCaptured) {\n        this.ctx.fillStyle = this.colorMap.captured;\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n      }\n\n      // 绘制逃脱状态\n      if (this.escaped) {\n        this.ctx.fillStyle = 'rgba(255, 248, 225, 0.5)'; // 逃脱背景色\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n      }\n\n      // 绘制轨迹（如果启用）\n      if (this.showTrails) {\n        this.drawTrails();\n      }\n\n      // 绘制视野和通信范围（如果启用）\n      if (this.showVisionRange || this.showCommunicationRange) {\n        this.drawRanges();\n      }\n\n      // 获取处理后的数据\n      var huntersArray = this.ensureHuntersArray();\n      var targetsArray = this.ensureTargetsArray();\n\n      // 使用安全的方式绘制猎手\n      if (Array.isArray(huntersArray)) {\n        for (var i = 0; i < huntersArray.length; i++) {\n          var hunter = huntersArray[i];\n          if (hunter && Array.isArray(hunter.position)) {\n            this.drawAgent(hunter, 'hunter');\n          }\n        }\n      }\n\n      // 使用安全的方式绘制目标\n      if (Array.isArray(targetsArray)) {\n        for (var _i3 = 0; _i3 < targetsArray.length; _i3++) {\n          var target = targetsArray[_i3];\n          if (target && Array.isArray(target.position)) {\n            this.drawAgent(target, 'target');\n          }\n        }\n      }\n\n      // 更新之前的位置\n      this.updatePreviousPositions();\n      this.previousIsRunning = this.isRunning;\n      this.previousIsCaptured = this.isCaptured;\n      this.previousEscaped = this.escaped;\n    },\n    // 单独绘制轨迹\n    drawTrails: function drawTrails() {\n      // 获取处理后的数据\n      var huntersArray = this.ensureHuntersArray();\n      var targetsArray = this.ensureTargetsArray();\n\n      // 绘制猎手轨迹\n      for (var i = 0; i < huntersArray.length; i++) {\n        var hunter = huntersArray[i];\n        if (hunter && hunter.history && Array.isArray(hunter.history) && hunter.history.length > 1) {\n          this.ctx.beginPath();\n          var startPos = this.transformPosition(hunter.history[0]);\n          this.ctx.moveTo(startPos.x, startPos.y);\n          for (var j = 1; j < hunter.history.length; j++) {\n            if (Array.isArray(hunter.history[j])) {\n              var histPos = this.transformPosition(hunter.history[j]);\n              this.ctx.lineTo(histPos.x, histPos.y);\n            }\n          }\n          this.ctx.strokeStyle = this.colorMap.trail;\n          this.ctx.lineWidth = 1.5;\n          this.ctx.stroke();\n        }\n      }\n\n      // 绘制目标轨迹\n      for (var _i4 = 0; _i4 < targetsArray.length; _i4++) {\n        var target = targetsArray[_i4];\n        if (target && target.history && Array.isArray(target.history) && target.history.length > 1) {\n          this.ctx.beginPath();\n          var _startPos = this.transformPosition(target.history[0]);\n          this.ctx.moveTo(_startPos.x, _startPos.y);\n          for (var _j = 1; _j < target.history.length; _j++) {\n            if (Array.isArray(target.history[_j])) {\n              var _histPos = this.transformPosition(target.history[_j]);\n              this.ctx.lineTo(_histPos.x, _histPos.y);\n            }\n          }\n          this.ctx.strokeStyle = this.colorMap.target;\n          this.ctx.lineWidth = 1.5;\n          this.ctx.stroke();\n        }\n      }\n    },\n    // 单独绘制视野和通信范围\n    drawRanges: function drawRanges() {\n      // 获取处理后的数据\n      var huntersArray = this.ensureHuntersArray();\n      var targetsArray = this.ensureTargetsArray();\n\n      // 绘制猎手视野和通信范围\n      for (var i = 0; i < huntersArray.length; i++) {\n        var hunter = huntersArray[i];\n        if (!hunter || !Array.isArray(hunter.position)) continue;\n        var pos = this.transformPosition(hunter.position);\n\n        // 绘制视野范围\n        if (this.showVisionRange && hunter.vision_range) {\n          this.ctx.beginPath();\n          this.ctx.arc(pos.x, pos.y, hunter.vision_range * this.scale, 0, Math.PI * 2);\n          this.ctx.fillStyle = this.colorMap.vision;\n          this.ctx.fill();\n        }\n\n        // 绘制通信范围\n        if (this.showCommunicationRange && hunter.communication_range) {\n          this.ctx.beginPath();\n          this.ctx.arc(pos.x, pos.y, hunter.communication_range * this.scale, 0, Math.PI * 2);\n          this.ctx.fillStyle = this.colorMap.communication;\n          this.ctx.fill();\n        }\n\n        // 绘制捕获范围\n        this.ctx.beginPath();\n        this.ctx.arc(pos.x, pos.y, 10 * this.scale, 0, Math.PI * 2); // 捕获范围固定为10\n        this.ctx.fillStyle = this.colorMap.captureRange;\n        this.ctx.fill();\n      }\n\n      // 绘制目标视野范围\n      for (var _i5 = 0; _i5 < targetsArray.length; _i5++) {\n        var target = targetsArray[_i5];\n        if (!target || !Array.isArray(target.position)) continue;\n        if (this.showVisionRange && target.vision_range) {\n          var _pos = this.transformPosition(target.position);\n          this.ctx.beginPath();\n          this.ctx.arc(_pos.x, _pos.y, target.vision_range * this.scale, 0, Math.PI * 2);\n          this.ctx.fillStyle = 'rgba(244, 67, 54, 0.1)'; // 半透明红色\n          this.ctx.fill();\n        }\n      }\n    },\n    // 绘制智能体\n    drawAgent: function drawAgent(agent, type) {\n      var pos = this.transformPosition(agent.position);\n\n      // 目标的浮动动画\n      var offsetY = 0;\n      if (type === 'target') {\n        offsetY = Math.sin(this.floatOffset) * 3; // 浮动效果\n        this.drawCaptureRadius(pos, offsetY);\n      }\n\n      // 绘制智能体\n      this.ctx.beginPath();\n      var radius = type === 'hunter' ? 6 : 8; // 稍微增大智能体尺寸\n      this.ctx.arc(pos.x, pos.y + offsetY, radius, 0, Math.PI * 2);\n      this.ctx.fillStyle = this.colorMap[type];\n      this.ctx.fill();\n\n      // 添加发光效果\n      this.ctx.shadowColor = type === 'hunter' ? 'rgba(63, 81, 181, 0.5)' : 'rgba(244, 67, 54, 0.5)';\n      this.ctx.shadowBlur = 10;\n      this.ctx.stroke();\n      this.ctx.shadowBlur = 0; // 重置阴影效果\n\n      // 绘制ID标签（可选，使UI更干净）\n      if (this.showLabels) {\n        // 使用配置选项\n        this.ctx.font = '10px Arial';\n        this.ctx.fillStyle = '#000';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(agent.id.toString(), pos.x, pos.y + offsetY + (type === 'hunter' ? 15 : 20));\n      }\n    },\n    // 新增方法：绘制目标捕获半径\n    drawCaptureRadius: function drawCaptureRadius(pos, offsetY) {\n      var pulseScale = 1 + this.pulseState * 0.15; // 脉冲效果，范围是1.0到1.15\n\n      this.ctx.beginPath();\n      this.ctx.arc(pos.x, pos.y + offsetY, 30 * pulseScale, 0, Math.PI * 2);\n      this.ctx.strokeStyle = 'rgba(76, 175, 80, 0.6)';\n      this.ctx.setLineDash([5, 3]); // 虚线效果\n      this.ctx.lineWidth = 1.5;\n      this.ctx.stroke();\n      this.ctx.setLineDash([]); // 重置线型\n    },\n    // 转换坐标\n    transformPosition: function transformPosition(position) {\n      // 检查position是否有效\n      if (!Array.isArray(position) || position.length < 2) {\n        console.warn('无效的position数据:', position);\n        return {\n          x: 0,\n          y: 0\n        };\n      }\n\n      // 将模拟坐标转换为画布坐标\n      return {\n        x: position[0] * this.scale,\n        y: position[1] * this.scale\n      };\n    },\n    // 清除特定区域\n    clearAgentArea: function clearAgentArea(position) {\n      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n      var pos = this.transformPosition(position);\n      this.ctx.clearRect(pos.x - radius, pos.y - radius, radius * 2, radius * 2);\n    }\n  },\n  watch: {\n    hunters: {\n      handler: function handler() {\n        // 设置需要渲染标记\n        this.needsRender = true;\n      },\n      deep: true\n    },\n    targets: {\n      handler: function handler() {\n        // 设置需要渲染标记\n        this.needsRender = true;\n      },\n      deep: true\n    },\n    obstacles: {\n      handler: function handler(newObstacles) {\n        if (Array.isArray(newObstacles)) {\n          this.localObstacles = _toConsumableArray(newObstacles);\n          // 设置需要渲染标记\n          this.needsRender = true;\n        }\n      },\n      deep: true,\n      immediate: true\n    },\n    isRunning: function isRunning(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.needsRender = true;\n      }\n    },\n    isCaptured: function isCaptured(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.needsRender = true;\n        this.lastRenderState.isCaptured = newVal;\n      }\n    },\n    escaped: function escaped(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.needsRender = true;\n        this.lastRenderState.isEscaped = newVal;\n      }\n    },\n    showTrails: function showTrails(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.needsRender = true;\n      }\n    },\n    showVisionRange: function showVisionRange(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.needsRender = true;\n      }\n    },\n    showCommunicationRange: function showCommunicationRange(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.needsRender = true;\n      }\n    },\n    environmentSize: function environmentSize() {\n      this.scale = this.canvasSize / this.environmentSize;\n      this.needsRender = true;\n    }\n  }\n};","map":{"version":3,"names":["name","props","hunters","type","Array","required","targets","environmentSize","Number","isRunning","Boolean","isCaptured","escaped","showTrails","showVisionRange","showCommunicationRange","obstacles","default","data","canvasSize","canvas","ctx","scale","colorMap","hunter","target","vision","communication","trail","captureRange","captured","obstacle","previousPositions","localObstacles","isArray","_toConsumableArray","showObstacles","renderTimer","lastRenderTime","targetFPS","renderCount","animationFrameId","animationFrames","pulseDirection","pulseState","floatOffset","showLabels","previousIsRunning","previousIsCaptured","previousEscaped","needsRender","lastRenderState","isEscaped","huntersCache","targetsCache","mounted","initCanvas","drawSimulation","window","addEventListener","handleResize","startRenderLoop","beforeDestroy","removeEventListener","stopRenderLoop","clearTimeout","methods","$refs","getContext","updatePreviousPositions","_this","setTimeout","performance","now","requestAnimationFrame","renderLoop","cancelAnimationFrame","timestamp","_this2","stateChanged","elapsed","frameTime","updateAnimationState","drawOptimizedSimulation","error","console","ensureHuntersArray","result","JSON","parse","e","ensureTargetsArray","hasPositionsChanged","length","threshold","huntersArray","targetsArray","i","prevHunter","position","Math","abs","prevTarget","map","id","clearRect","drawBackground","strokeStyle","lineWidth","strokeRect","drawObstacles","fillStyle","fillRect","drawTrails","drawRanges","drawAgent","obstaclesToRender","pos","transformPosition","_typeof","x","y","concat","radius","isNaN","beginPath","arc","PI","fill","stroke","font","textAlign","textBaseline","fillText","gridSize","width","height","moveTo","lineTo","forceFullRedraw","arguments","undefined","history","startPos","j","histPos","vision_range","communication_range","agent","offsetY","sin","drawCaptureRadius","shadowColor","shadowBlur","toString","pulseScale","setLineDash","warn","clearAgentArea","watch","handler","deep","newObstacles","immediate","newVal","oldVal"],"sources":["src/components/SimulationCanvas.vue"],"sourcesContent":["<template>\r\n  <div class=\"simulation-canvas\">\r\n    <canvas \r\n      ref=\"canvas\" \r\n      :width=\"canvasSize\" \r\n      :height=\"canvasSize\" \r\n      class=\"simulation-canvas__area\"\r\n    ></canvas>\r\n    \r\n    <!-- 捕获成功提示覆盖层 -->\r\n    <div \r\n      v-if=\"isCaptured\" \r\n      class=\"capture-overlay\"\r\n    >\r\n      <div class=\"capture-message\">\r\n        <v-icon large color=\"success\">mdi-check-circle</v-icon>\r\n        <span>目标已捕获!</span>\r\n      </div>\r\n    </div>\r\n    \r\n    <!-- 逃脱成功提示覆盖层 -->\r\n    <div \r\n      v-if=\"escaped\" \r\n      class=\"escape-overlay\"\r\n    >\r\n      <div class=\"escape-message\">\r\n        <v-icon large color=\"warning\">mdi-run-fast</v-icon>\r\n        <span>目标成功逃脱!</span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nexport default {\r\n  name: 'SimulationCanvas',\r\n  props: {\r\n    hunters: {\r\n      type: Array,\r\n      required: true\r\n    },\r\n    targets: {\r\n      type: Array,\r\n      required: true\r\n    },\r\n    environmentSize: {\r\n      type: Number,\r\n      default: 500\r\n    },\r\n    isRunning: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    isCaptured: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    escaped: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    showTrails: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    showVisionRange: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    showCommunicationRange: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    obstacles: {\r\n      type: Array,\r\n      default: () => [] // 确保默认为空数组\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      canvasSize: 600,\r\n      canvas: null,\r\n      ctx: null,\r\n      scale: 1,\r\n      colorMap: {\r\n        hunter: '#3949AB', // 更深的蓝色\r\n        target: '#e53935', // 更鲜艳的红色\r\n        vision: 'rgba(57, 73, 171, 0.1)', // 半透明蓝色\r\n        communication: 'rgba(57, 73, 171, 0.05)', // 更透明的蓝色\r\n        trail: 'rgba(57, 73, 171, 0.4)', // 半透明蓝色\r\n        captureRange: 'rgba(76, 175, 80, 0.4)', // 更明显的绿色\r\n        captured: 'rgba(244, 67, 54, 0.25)', // 半透明红色\r\n        obstacle: 'rgba(100, 100, 110, 0.8)' // 障碍物颜色\r\n      },\r\n      // 跟踪之前的位置，用于优化渲染\r\n      previousPositions: {\r\n        hunters: [],\r\n        targets: []\r\n      },\r\n      // 本地obstacles引用，防止未定义错误\r\n      localObstacles: Array.isArray(this.obstacles) ? [...this.obstacles] : [],\r\n      showObstacles: true,  // 默认显示障碍物\r\n      // 防抖渲染计时器\r\n      renderTimer: null,\r\n      // 帧率控制\r\n      lastRenderTime: 0,\r\n      targetFPS: 30,\r\n      // 渲染计数，用于降低非必要渲染的频率\r\n      renderCount: 0,\r\n      // 动画相关\r\n      animationFrameId: null,\r\n      animationFrames: 0,\r\n      pulseDirection: 1,\r\n      pulseState: 0,\r\n      floatOffset: 0,\r\n      // 是否显示标签\r\n      showLabels: false,\r\n      // 记录前一次运行状态\r\n      previousIsRunning: false,\r\n      previousIsCaptured: false,\r\n      previousEscaped: false,\r\n      // 新增：需要重新渲染标志\r\n      needsRender: false,\r\n      // 最后一次渲染状态\r\n      lastRenderState: {\r\n        isCaptured: false,\r\n        isEscaped: false\r\n      },\r\n      // 缓存数据\r\n      huntersCache: null,\r\n      targetsCache: null\r\n    };\r\n  },\r\n  mounted() {\r\n    this.initCanvas();\r\n    // 初始化本地obstacles\r\n    this.localObstacles = Array.isArray(this.obstacles) ? [...this.obstacles] : [];\r\n    this.drawSimulation();\r\n    \r\n    // 添加窗口大小变化监听\r\n    window.addEventListener('resize', this.handleResize);\r\n    \r\n    // 使用requestAnimationFrame实现高效渲染循环\r\n    this.startRenderLoop();\r\n  },\r\n  beforeDestroy() {\r\n    // 清理事件监听器\r\n    window.removeEventListener('resize', this.handleResize);\r\n    \r\n    // 停止渲染循环\r\n    this.stopRenderLoop();\r\n    \r\n    // 清理计时器\r\n    if (this.renderTimer) {\r\n      clearTimeout(this.renderTimer);\r\n    }\r\n    \r\n    // 清理缓存\r\n    this.huntersCache = null;\r\n    this.targetsCache = null;\r\n  },\r\n  methods: {\r\n    // 初始化画布\r\n    initCanvas() {\r\n      this.canvas = this.$refs.canvas;\r\n      this.ctx = this.canvas.getContext('2d');\r\n      this.scale = this.canvasSize / this.environmentSize;\r\n      \r\n      // 初始化previousPositions\r\n      this.updatePreviousPositions();\r\n    },\r\n    \r\n    // 处理窗口大小变化\r\n    handleResize() {\r\n      // 防抖处理\r\n      if (this.renderTimer) {\r\n        clearTimeout(this.renderTimer);\r\n      }\r\n      \r\n      this.renderTimer = setTimeout(() => {\r\n        // 重新计算画布大小（可选，如果需要响应式调整画布大小）\r\n        // this.canvasSize = Math.min(window.innerWidth * 0.7, 600);\r\n        this.scale = this.canvasSize / this.environmentSize;\r\n        this.needsRender = true;\r\n        this.drawSimulation(true); // 强制完全重绘\r\n      }, 200);\r\n    },\r\n    \r\n    // 启动渲染循环\r\n    startRenderLoop() {\r\n      if (!this.animationFrameId) {\r\n        this.lastRenderTime = performance.now();\r\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\r\n      }\r\n    },\r\n    \r\n    // 停止渲染循环\r\n    stopRenderLoop() {\r\n      if (this.animationFrameId) {\r\n        cancelAnimationFrame(this.animationFrameId);\r\n        this.animationFrameId = null;\r\n      }\r\n    },\r\n    \r\n    // 渲染循环\r\n    renderLoop(timestamp) {\r\n      try {\r\n        // 判断模拟状态是否变化\r\n        const stateChanged = this.isCaptured !== this.lastRenderState.isCaptured || \r\n                           this.escaped !== this.lastRenderState.isEscaped;\r\n        \r\n        // 如果模拟已结束且状态未变化，减少渲染频率\r\n        if ((this.isCaptured || this.escaped) && !stateChanged && !this.needsRender) {\r\n          // 模拟已结束，使用低频率更新\r\n          setTimeout(() => {\r\n            this.animationFrameId = requestAnimationFrame(this.renderLoop);\r\n          }, 1000); // 降低为每秒一帧\r\n          return;\r\n        }\r\n        \r\n        // 更新最后渲染状态\r\n        if (stateChanged) {\r\n          this.lastRenderState.isCaptured = this.isCaptured;\r\n          this.lastRenderState.isEscaped = this.escaped;\r\n          this.needsRender = true;\r\n        }\r\n        \r\n        // 正常渲染逻辑\r\n        const elapsed = timestamp - this.lastRenderTime;\r\n        const frameTime = 1000 / this.targetFPS;\r\n        \r\n        if (elapsed >= frameTime || this.needsRender) {\r\n          this.lastRenderTime = timestamp;\r\n          \r\n          // 更新动画状态\r\n          this.updateAnimationState();\r\n          \r\n          // 仅在需要时渲染\r\n          if (this.needsRender || this.isRunning || this.animationFrames % 15 === 0) {\r\n            this.drawOptimizedSimulation();\r\n            this.needsRender = false;\r\n          }\r\n        }\r\n        \r\n        // 设置下一帧\r\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\r\n      } catch (error) {\r\n        console.error('渲染循环错误:', error);\r\n        // 错误恢复：停止当前循环，稍后重试\r\n        if (this.animationFrameId) {\r\n          cancelAnimationFrame(this.animationFrameId);\r\n          this.animationFrameId = null;\r\n        }\r\n        \r\n        // 延迟后尝试重启循环\r\n        setTimeout(() => {\r\n          this.startRenderLoop();\r\n        }, 2000);\r\n      }\r\n    },\r\n    \r\n    // 更新动画状态\r\n    updateAnimationState() {\r\n      this.animationFrames++;\r\n      if (this.animationFrames % 3 === 0) {\r\n        // 更新脉冲效果\r\n        this.pulseState += 0.05 * this.pulseDirection;\r\n        if (this.pulseState >= 1) {\r\n          this.pulseState = 1;\r\n          this.pulseDirection = -1;\r\n        } else if (this.pulseState <= 0) {\r\n          this.pulseState = 0;\r\n          this.pulseDirection = 1;\r\n        }\r\n        \r\n        // 更新浮动效果\r\n        this.floatOffset += 0.1;\r\n      }\r\n    },\r\n    \r\n    // 处理hunters数据\r\n    ensureHuntersArray() {\r\n      // 如果模拟已完成且有缓存，使用缓存\r\n      if ((this.isCaptured || this.escaped) && this.huntersCache) {\r\n        return this.huntersCache;\r\n      }\r\n      \r\n      // 正常处理逻辑\r\n      let result = [];\r\n      if (typeof this.hunters === 'string') {\r\n        try {\r\n          result = JSON.parse(this.hunters);\r\n        } catch (e) {\r\n          console.error('无法解析hunters数据:', e);\r\n        }\r\n      } else if (Array.isArray(this.hunters)) {\r\n        result = [...this.hunters]; // 创建浅拷贝以避免直接操作原始数据\r\n      }\r\n      \r\n      // 如果模拟已完成，缓存结果\r\n      if (this.isCaptured || this.escaped) {\r\n        this.huntersCache = result;\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    // 处理targets数据\r\n    ensureTargetsArray() {\r\n      // 如果模拟已完成且有缓存，使用缓存\r\n      if ((this.isCaptured || this.escaped) && this.targetsCache) {\r\n        return this.targetsCache;\r\n      }\r\n      \r\n      // 正常处理逻辑\r\n      let result = [];\r\n      if (typeof this.targets === 'string') {\r\n        try {\r\n          result = JSON.parse(this.targets);\r\n        } catch (e) {\r\n          console.error('无法解析targets数据:', e);\r\n        }\r\n      } else if (Array.isArray(this.targets)) {\r\n        result = [...this.targets]; // 创建浅拷贝以避免直接操作原始数据\r\n      }\r\n      \r\n      // 如果模拟已完成，缓存结果\r\n      if (this.isCaptured || this.escaped) {\r\n        this.targetsCache = result;\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    // 检查位置是否有变化\r\n    hasPositionsChanged() {\r\n      // 优化：快速检查数组长度变化\r\n      if (this.hunters.length !== this.previousPositions.hunters.length ||\r\n          this.targets.length !== this.previousPositions.targets.length) {\r\n        return true;\r\n      }\r\n      \r\n      // 检查运行状态变化\r\n      if (this.isRunning !== this.previousIsRunning ||\r\n          this.isCaptured !== this.previousIsCaptured ||\r\n          this.escaped !== this.previousEscaped) {\r\n        this.previousIsRunning = this.isRunning;\r\n        this.previousIsCaptured = this.isCaptured;\r\n        this.previousEscaped = this.escaped;\r\n        return true;\r\n      }\r\n      \r\n      // 渲染计数，每5帧强制完全重绘一次（避免累积误差）\r\n      this.renderCount++;\r\n      if (this.renderCount >= 5) {\r\n        this.renderCount = 0;\r\n        return true;\r\n      }\r\n      \r\n      // 只有在运行中或首次渲染时，才进行位置变化检查\r\n      if (!this.isRunning && this.previousPositions.hunters.length > 0) {\r\n        return false;\r\n      }\r\n      \r\n      // 智能体位置变化检测\r\n      const threshold = 0.5; // 位置变化阈值\r\n      \r\n      // 确保数据格式正确\r\n      const huntersArray = this.ensureHuntersArray();\r\n      const targetsArray = this.ensureTargetsArray();\r\n      \r\n      // 检查猎手位置变化\r\n      for (let i = 0; i < huntersArray.length; i++) {\r\n        const hunter = huntersArray[i];\r\n        const prevHunter = this.previousPositions.hunters[i];\r\n        \r\n        if (!prevHunter || !hunter) return true;\r\n        if (!Array.isArray(hunter.position) || !Array.isArray(prevHunter.position)) return true;\r\n        \r\n        if (Math.abs(hunter.position[0] - prevHunter.position[0]) > threshold ||\r\n            Math.abs(hunter.position[1] - prevHunter.position[1]) > threshold) {\r\n          return true;\r\n        }\r\n      }\r\n      \r\n      // 检查目标位置变化\r\n      for (let i = 0; i < targetsArray.length; i++) {\r\n        const target = targetsArray[i];\r\n        const prevTarget = this.previousPositions.targets[i];\r\n        \r\n        if (!prevTarget || !target) return true;\r\n        if (!Array.isArray(target.position) || !Array.isArray(prevTarget.position)) return true;\r\n        \r\n        if (Math.abs(target.position[0] - prevTarget.position[0]) > threshold ||\r\n            Math.abs(target.position[1] - prevTarget.position[1]) > threshold) {\r\n          return true;\r\n        }\r\n      }\r\n      \r\n      return false;\r\n    },\r\n    \r\n    // 更新之前的位置\r\n    updatePreviousPositions() {\r\n      // 确保数据格式正确\r\n      const huntersArray = this.ensureHuntersArray();\r\n      const targetsArray = this.ensureTargetsArray();\r\n      \r\n      // 深拷贝位置数据，确保防御性检查\r\n      this.previousPositions.hunters = huntersArray.map(hunter => {\r\n        if (hunter && Array.isArray(hunter.position)) {\r\n          return {\r\n            id: hunter.id,\r\n            position: [...hunter.position]\r\n          };\r\n        }\r\n        return { id: -1, position: [0, 0] }; // 默认值，防止错误\r\n      });\r\n      \r\n      this.previousPositions.targets = targetsArray.map(target => {\r\n        if (target && Array.isArray(target.position)) {\r\n          return {\r\n            id: target.id,\r\n            position: [...target.position]\r\n          };\r\n        }\r\n        return { id: -1, position: [0, 0] }; // 默认值，防止错误\r\n      });\r\n    },\r\n    \r\n    // 优化的绘制方法\r\n    drawOptimizedSimulation() {\r\n      if (!this.ctx) return;\r\n      \r\n      try {\r\n        // 清除画布\r\n        this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\r\n        this.drawBackground();\r\n        \r\n        // 绘制环境边界\r\n        this.ctx.strokeStyle = '#ccc';\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\r\n        \r\n        // 绘制障碍物 - 只在必要时绘制\r\n        if (this.obstacles && Array.isArray(this.obstacles) && this.obstacles.length > 0 && this.showObstacles) {\r\n          this.drawObstacles();\r\n        }\r\n        \r\n        // 绘制捕获或逃脱状态\r\n        if (this.isCaptured) {\r\n          this.ctx.fillStyle = this.colorMap.captured;\r\n          this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n        } else if (this.escaped) {\r\n          this.ctx.fillStyle = 'rgba(255, 248, 225, 0.5)'; // 逃脱背景色\r\n          this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n        }\r\n        \r\n        // 绘制轨迹\r\n        if (this.showTrails) {\r\n          this.drawTrails();\r\n        }\r\n        \r\n        // 绘制视野和通信范围\r\n        if (this.showVisionRange || this.showCommunicationRange) {\r\n          this.drawRanges();\r\n        }\r\n        \r\n        // 获取处理后的数据\r\n        const huntersArray = this.ensureHuntersArray();\r\n        const targetsArray = this.ensureTargetsArray();\r\n        \r\n        // 使用安全的方式绘制猎手\r\n        if (Array.isArray(huntersArray)) {\r\n          for (let i = 0; i < huntersArray.length; i++) {\r\n            const hunter = huntersArray[i];\r\n            if (hunter && Array.isArray(hunter.position)) {\r\n              this.drawAgent(hunter, 'hunter');\r\n            }\r\n          }\r\n        }\r\n        \r\n        // 使用安全的方式绘制目标\r\n        if (Array.isArray(targetsArray)) {\r\n          for (let i = 0; i < targetsArray.length; i++) {\r\n            const target = targetsArray[i];\r\n            if (target && Array.isArray(target.position)) {\r\n              this.drawAgent(target, 'target');\r\n            }\r\n          }\r\n        }\r\n        \r\n        // 更新位置缓存，用于下次渲染比较\r\n        if (!this.isCaptured && !this.escaped) {\r\n          this.updatePreviousPositions();\r\n        }\r\n      } catch (error) {\r\n        console.error('绘制模拟时出错:', error);\r\n        // 不中断渲染循环\r\n      }\r\n    },\r\n    \r\n    // 绘制障碍物\r\n    drawObstacles() {\r\n      let obstaclesToRender = null;\r\n      \r\n      // 首先检查本地障碍物数组\r\n      if (Array.isArray(this.localObstacles) && this.localObstacles.length > 0) {\r\n        obstaclesToRender = this.localObstacles;\r\n      } \r\n      // 然后检查props障碍物数组\r\n      else if (Array.isArray(this.obstacles) && this.obstacles.length > 0) {\r\n        obstaclesToRender = this.obstacles;\r\n        // 同步更新本地数据\r\n        this.localObstacles = [...this.obstacles];\r\n      } \r\n      else {\r\n        return;\r\n      }\r\n\r\n      // 遍历绘制每个障碍物\r\n      for (let i = 0; i < obstaclesToRender.length; i++) {\r\n        const obstacle = obstaclesToRender[i];\r\n        \r\n        // 检查障碍物数据完整性\r\n        if (!obstacle) {\r\n          continue;\r\n        }\r\n\r\n        // 确保position数据存在并格式正确\r\n        let position = obstacle.position;\r\n        if (!position) {\r\n          continue;\r\n        }\r\n\r\n        // 处理position可能的不同格式\r\n        let pos;\r\n        try {\r\n          if (Array.isArray(position)) {\r\n            pos = this.transformPosition(position);\r\n          } else if (typeof position === 'object') {\r\n            // 对象格式 {x, y}\r\n            if ('x' in position && 'y' in position) {\r\n              pos = {\r\n                x: position.x * this.scale,\r\n                y: position.y * this.scale\r\n              };\r\n            } else {\r\n              continue;\r\n            }\r\n          } else {\r\n            continue;\r\n          }\r\n        } catch (e) {\r\n          console.error(`处理障碍物[${i}]位置时出错:`, e);\r\n          continue;\r\n        }\r\n\r\n        // 获取并检查半径\r\n        const radius = obstacle.radius * this.scale;\r\n        if (!radius || isNaN(radius) || radius <= 0) {\r\n          continue;\r\n        }\r\n\r\n        // 绘制障碍物\r\n        try {\r\n          // 设置样式\r\n          this.ctx.fillStyle = 'rgba(100, 100, 110, 0.8)';\r\n          this.ctx.strokeStyle = 'rgba(80, 80, 90, 0.9)';\r\n          this.ctx.lineWidth = 2;\r\n          \r\n          // 绘制圆形\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\r\n          this.ctx.fill();\r\n          this.ctx.stroke();\r\n          \r\n          // 添加编号标签（便于调试）\r\n          this.ctx.fillStyle = 'white';\r\n          this.ctx.font = '12px Arial';\r\n          this.ctx.textAlign = 'center';\r\n          this.ctx.textBaseline = 'middle';\r\n          this.ctx.fillText(`${i}`, pos.x, pos.y);\r\n        } catch (e) {\r\n          console.error(`绘制障碍物[${i}]时出错:`, e);\r\n        }\r\n      }\r\n    },\r\n\r\n    drawBackground() {\r\n      const gridSize = 25 * this.scale;\r\n      const width = this.canvasSize;\r\n      const height = this.canvasSize;\r\n      \r\n      // 填充背景色\r\n      this.ctx.fillStyle = '#f5f7fa';\r\n      this.ctx.fillRect(0, 0, width, height);\r\n      \r\n      this.ctx.strokeStyle = 'rgba(200, 200, 220, 0.3)';\r\n      this.ctx.lineWidth = 1;\r\n      \r\n      // 绘制网格线\r\n      for (let x = 0; x <= width; x += gridSize) {\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(x, 0);\r\n        this.ctx.lineTo(x, height);\r\n        this.ctx.stroke();\r\n      }\r\n      \r\n      for (let y = 0; y <= height; y += gridSize) {\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(0, y);\r\n        this.ctx.lineTo(width, y);\r\n        this.ctx.stroke();\r\n      }\r\n      \r\n      // 添加坐标轴\r\n      this.ctx.strokeStyle = 'rgba(150, 150, 180, 0.4)';\r\n      this.ctx.lineWidth = 2;\r\n      \r\n      // x轴\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(0, height/2);\r\n      this.ctx.lineTo(width, height/2);\r\n      this.ctx.stroke();\r\n      \r\n      // y轴\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(width/2, 0);\r\n      this.ctx.lineTo(width/2, height);\r\n      this.ctx.stroke();\r\n    },\r\n    \r\n    // 完整重绘方法\r\n    drawSimulation(forceFullRedraw = false) {\r\n      if (!this.ctx) return;\r\n      \r\n      // 如果不需要强制重绘，使用优化版本\r\n      if (!forceFullRedraw && this.previousPositions.hunters.length > 0) {\r\n        return this.drawOptimizedSimulation();\r\n      }\r\n      \r\n      // 设置完全重绘所需的标记\r\n      this.needsRender = true;\r\n      \r\n      // 清除画布\r\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\r\n\r\n      this.drawBackground();\r\n      \r\n      // 绘制环境边界\r\n      this.ctx.strokeStyle = '#ccc';\r\n      this.ctx.lineWidth = 2;\r\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\r\n      \r\n      // 绘制障碍物 - 添加防御性检查\r\n      if (this.obstacles && Array.isArray(this.obstacles) && this.obstacles.length > 0 && this.showObstacles) {\r\n        this.drawObstacles();\r\n      }\r\n      \r\n      // 绘制捕获状态\r\n      if (this.isCaptured) {\r\n        this.ctx.fillStyle = this.colorMap.captured;\r\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n      }\r\n      \r\n      // 绘制逃脱状态\r\n      if (this.escaped) {\r\n        this.ctx.fillStyle = 'rgba(255, 248, 225, 0.5)'; // 逃脱背景色\r\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n      }\r\n      \r\n      // 绘制轨迹（如果启用）\r\n      if (this.showTrails) {\r\n        this.drawTrails();\r\n      }\r\n      \r\n      // 绘制视野和通信范围（如果启用）\r\n      if (this.showVisionRange || this.showCommunicationRange) {\r\n        this.drawRanges();\r\n      }\r\n      \r\n      // 获取处理后的数据\r\n      const huntersArray = this.ensureHuntersArray();\r\n      const targetsArray = this.ensureTargetsArray();\r\n      \r\n      // 使用安全的方式绘制猎手\r\n      if (Array.isArray(huntersArray)) {\r\n        for (let i = 0; i < huntersArray.length; i++) {\r\n          const hunter = huntersArray[i];\r\n          if (hunter && Array.isArray(hunter.position)) {\r\n            this.drawAgent(hunter, 'hunter');\r\n          }\r\n        }\r\n      }\r\n      \r\n      // 使用安全的方式绘制目标\r\n      if (Array.isArray(targetsArray)) {\r\n        for (let i = 0; i < targetsArray.length; i++) {\r\n          const target = targetsArray[i];\r\n          if (target && Array.isArray(target.position)) {\r\n            this.drawAgent(target, 'target');\r\n          }\r\n        }\r\n      }\r\n      \r\n      // 更新之前的位置\r\n      this.updatePreviousPositions();\r\n      this.previousIsRunning = this.isRunning;\r\n      this.previousIsCaptured = this.isCaptured;\r\n      this.previousEscaped = this.escaped;\r\n    },\r\n    \r\n    // 单独绘制轨迹\r\n    drawTrails() {\r\n      // 获取处理后的数据\r\n      const huntersArray = this.ensureHuntersArray();\r\n      const targetsArray = this.ensureTargetsArray();\r\n      \r\n      // 绘制猎手轨迹\r\n      for (let i = 0; i < huntersArray.length; i++) {\r\n        const hunter = huntersArray[i];\r\n        if (hunter && hunter.history && Array.isArray(hunter.history) && hunter.history.length > 1) {\r\n          this.ctx.beginPath();\r\n          const startPos = this.transformPosition(hunter.history[0]);\r\n          this.ctx.moveTo(startPos.x, startPos.y);\r\n          \r\n          for (let j = 1; j < hunter.history.length; j++) {\r\n            if (Array.isArray(hunter.history[j])) {\r\n              const histPos = this.transformPosition(hunter.history[j]);\r\n              this.ctx.lineTo(histPos.x, histPos.y);\r\n            }\r\n          }\r\n          \r\n          this.ctx.strokeStyle = this.colorMap.trail;\r\n          this.ctx.lineWidth = 1.5;\r\n          this.ctx.stroke();\r\n        }\r\n      }\r\n      \r\n      // 绘制目标轨迹\r\n      for (let i = 0; i < targetsArray.length; i++) {\r\n        const target = targetsArray[i];\r\n        if (target && target.history && Array.isArray(target.history) && target.history.length > 1) {\r\n          this.ctx.beginPath();\r\n          const startPos = this.transformPosition(target.history[0]);\r\n          this.ctx.moveTo(startPos.x, startPos.y);\r\n          \r\n          for (let j = 1; j < target.history.length; j++) {\r\n            if (Array.isArray(target.history[j])) {\r\n              const histPos = this.transformPosition(target.history[j]);\r\n              this.ctx.lineTo(histPos.x, histPos.y);\r\n            }\r\n          }\r\n          \r\n          this.ctx.strokeStyle = this.colorMap.target;\r\n          this.ctx.lineWidth = 1.5;\r\n          this.ctx.stroke();\r\n        }\r\n      }\r\n    },\r\n    \r\n    // 单独绘制视野和通信范围\r\n    drawRanges() {\r\n      // 获取处理后的数据\r\n      const huntersArray = this.ensureHuntersArray();\r\n      const targetsArray = this.ensureTargetsArray();\r\n      \r\n      // 绘制猎手视野和通信范围\r\n      for (let i = 0; i < huntersArray.length; i++) {\r\n        const hunter = huntersArray[i];\r\n        if (!hunter || !Array.isArray(hunter.position)) continue;\r\n        \r\n        const pos = this.transformPosition(hunter.position);\r\n        \r\n        // 绘制视野范围\r\n        if (this.showVisionRange && hunter.vision_range) {\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, hunter.vision_range * this.scale, 0, Math.PI * 2);\r\n          this.ctx.fillStyle = this.colorMap.vision;\r\n          this.ctx.fill();\r\n        }\r\n        \r\n        // 绘制通信范围\r\n        if (this.showCommunicationRange && hunter.communication_range) {\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, hunter.communication_range * this.scale, 0, Math.PI * 2);\r\n          this.ctx.fillStyle = this.colorMap.communication;\r\n          this.ctx.fill();\r\n        }\r\n        \r\n        // 绘制捕获范围\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(pos.x, pos.y, 10 * this.scale, 0, Math.PI * 2); // 捕获范围固定为10\r\n        this.ctx.fillStyle = this.colorMap.captureRange;\r\n        this.ctx.fill();\r\n      }\r\n      \r\n      // 绘制目标视野范围\r\n      for (let i = 0; i < targetsArray.length; i++) {\r\n        const target = targetsArray[i];\r\n        if (!target || !Array.isArray(target.position)) continue;\r\n        \r\n        if (this.showVisionRange && target.vision_range) {\r\n          const pos = this.transformPosition(target.position);\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, target.vision_range * this.scale, 0, Math.PI * 2);\r\n          this.ctx.fillStyle = 'rgba(244, 67, 54, 0.1)'; // 半透明红色\r\n          this.ctx.fill();\r\n        }\r\n      }\r\n    },\r\n    \r\n    // 绘制智能体\r\n    drawAgent(agent, type) {\r\n      const pos = this.transformPosition(agent.position);\r\n      \r\n      // 目标的浮动动画\r\n      let offsetY = 0;\r\n      if (type === 'target') {\r\n        offsetY = Math.sin(this.floatOffset) * 3; // 浮动效果\r\n        this.drawCaptureRadius(pos, offsetY);\r\n      }\r\n      \r\n      // 绘制智能体\r\n      this.ctx.beginPath();\r\n      const radius = type === 'hunter' ? 6 : 8; // 稍微增大智能体尺寸\r\n      this.ctx.arc(pos.x, pos.y + offsetY, radius, 0, Math.PI * 2);\r\n      this.ctx.fillStyle = this.colorMap[type];\r\n      this.ctx.fill();\r\n      \r\n      // 添加发光效果\r\n      this.ctx.shadowColor = type === 'hunter' ? 'rgba(63, 81, 181, 0.5)' : 'rgba(244, 67, 54, 0.5)';\r\n      this.ctx.shadowBlur = 10;\r\n      this.ctx.stroke();\r\n      this.ctx.shadowBlur = 0; // 重置阴影效果\r\n      \r\n      // 绘制ID标签（可选，使UI更干净）\r\n      if (this.showLabels) { // 使用配置选项\r\n        this.ctx.font = '10px Arial';\r\n        this.ctx.fillStyle = '#000';\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.fillText(agent.id.toString(), pos.x, pos.y + offsetY + (type === 'hunter' ? 15 : 20));\r\n      }\r\n    },\r\n    \r\n    // 新增方法：绘制目标捕获半径\r\n    drawCaptureRadius(pos, offsetY) {\r\n      const pulseScale = 1 + (this.pulseState * 0.15); // 脉冲效果，范围是1.0到1.15\r\n      \r\n      this.ctx.beginPath();\r\n      this.ctx.arc(pos.x, pos.y + offsetY, 30 * pulseScale, 0, Math.PI * 2);\r\n      this.ctx.strokeStyle = 'rgba(76, 175, 80, 0.6)';\r\n      this.ctx.setLineDash([5, 3]); // 虚线效果\r\n      this.ctx.lineWidth = 1.5;\r\n      this.ctx.stroke();\r\n      this.ctx.setLineDash([]); // 重置线型\r\n    },\r\n    \r\n    // 转换坐标\r\n    transformPosition(position) {\r\n      // 检查position是否有效\r\n      if (!Array.isArray(position) || position.length < 2) {\r\n        console.warn('无效的position数据:', position);\r\n        return { x: 0, y: 0 };\r\n      }\r\n      \r\n      // 将模拟坐标转换为画布坐标\r\n      return {\r\n        x: position[0] * this.scale,\r\n        y: position[1] * this.scale\r\n      }\r\n    },\r\n    \r\n    // 清除特定区域\r\n    clearAgentArea(position, radius = 20) {\r\n      const pos = this.transformPosition(position);\r\n      this.ctx.clearRect(pos.x - radius, pos.y - radius, radius * 2, radius * 2);\r\n    }\r\n  },\r\n  watch: {\r\n    hunters: {\r\n      handler() {\r\n        // 设置需要渲染标记\r\n        this.needsRender = true;\r\n      },\r\n      deep: true\r\n    },\r\n    targets: {\r\n      handler() {\r\n        // 设置需要渲染标记\r\n        this.needsRender = true;\r\n      },\r\n      deep: true\r\n    },\r\n    obstacles: {\r\n      handler(newObstacles) {\r\n        if (Array.isArray(newObstacles)) {\r\n          this.localObstacles = [...newObstacles];\r\n          // 设置需要渲染标记\r\n          this.needsRender = true;\r\n        }\r\n      },\r\n      deep: true,\r\n      immediate: true\r\n    },\r\n    isRunning(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.needsRender = true;\r\n      }\r\n    },\r\n    isCaptured(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.needsRender = true;\r\n        this.lastRenderState.isCaptured = newVal;\r\n      }\r\n    },\r\n    escaped(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.needsRender = true;\r\n        this.lastRenderState.isEscaped = newVal;\r\n      }\r\n    },\r\n    showTrails(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.needsRender = true;\r\n      }\r\n    },\r\n    showVisionRange(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.needsRender = true;\r\n      }\r\n    },\r\n    showCommunicationRange(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.needsRender = true;\r\n      }\r\n    },\r\n    environmentSize() {\r\n      this.scale = this.canvasSize / this.environmentSize;\r\n      this.needsRender = true;\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style scoped>\r\n.simulation-canvas {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  position: relative;\r\n  margin: 16px 0;\r\n}\r\n\r\n.simulation-canvas__area {\r\n  border: none;\r\n  border-radius: 8px;\r\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);\r\n  background-color: #fcfcff;\r\n}\r\n\r\n.capture-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background-color: rgba(255, 255, 255, 0.7);\r\n  border-radius: 8px;\r\n  animation: fadeIn 0.5s ease-in-out;\r\n}\r\n\r\n.capture-message {\r\n  background-color: rgba(255, 255, 255, 0.9);\r\n  padding: 16px 24px;\r\n  border-radius: 8px;\r\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 8px;\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: #4caf50;\r\n  animation: pulse 2s infinite;\r\n}\r\n\r\n.escape-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background-color: rgba(255, 248, 225, 0.7);\r\n  border-radius: 8px;\r\n  animation: fadeIn 0.5s ease-in-out;\r\n}\r\n\r\n.escape-message {\r\n  background-color: rgba(255, 255, 255, 0.9);\r\n  padding: 16px 24px;\r\n  border-radius: 8px;\r\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 8px;\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: #ff9800;\r\n  animation: pulse 2s infinite;\r\n}\r\n\r\n@keyframes fadeIn {\r\n  from { opacity: 0; }\r\n  to { opacity: 1; }\r\n}\r\n\r\n@keyframes pulse {\r\n  0% { transform: scale(1); }\r\n  50% { transform: scale(1.05); }\r\n  100% { transform: scale(1); }\r\n}\r\n</style>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}