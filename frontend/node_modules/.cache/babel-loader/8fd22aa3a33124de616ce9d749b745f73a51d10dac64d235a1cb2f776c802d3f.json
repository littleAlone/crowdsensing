{"ast":null,"code":"import _typeof from \"F:/python/course/crowdsensing/frontend/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _slicedToArray from \"F:/python/course/crowdsensing/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"F:/python/course/crowdsensing/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\nexport default {\n  name: 'SimulationCanvas',\n  props: {\n    hunters: {\n      type: Array,\n      required: true\n    },\n    targets: {\n      type: Array,\n      required: true\n    },\n    environmentSize: {\n      type: Number,\n      \"default\": 500\n    },\n    isRunning: {\n      type: Boolean,\n      \"default\": false\n    },\n    isCaptured: {\n      type: Boolean,\n      \"default\": false\n    },\n    showTrails: {\n      type: Boolean,\n      \"default\": true\n    },\n    showVisionRange: {\n      type: Boolean,\n      \"default\": false\n    },\n    showCommunicationRange: {\n      type: Boolean,\n      \"default\": false\n    },\n    obstacles: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      } // 确保默认为空数组\n    }\n  },\n  data: function data() {\n    return {\n      canvasSize: 600,\n      canvas: null,\n      ctx: null,\n      scale: 1,\n      colorMap: {\n        hunter: '#3949AB',\n        // 更深的蓝色\n        target: '#e53935',\n        // 更鲜艳的红色\n        vision: 'rgba(57, 73, 171, 0.1)',\n        // 半透明蓝色\n        communication: 'rgba(57, 73, 171, 0.05)',\n        // 更透明的蓝色\n        trail: 'rgba(57, 73, 171, 0.4)',\n        // 半透明蓝色\n        captureRange: 'rgba(76, 175, 80, 0.4)',\n        // 更明显的绿色\n        captured: 'rgba(244, 67, 54, 0.25)',\n        // 半透明红色\n        obstacle: 'rgba(100, 100, 110, 0.8)' // 障碍物颜色\n      },\n      // 新增：跟踪之前的位置，用于优化渲染\n      previousPositions: {\n        hunters: [],\n        targets: []\n      },\n      // 本地obstacles引用，防止未定义错误\n      localObstacles: [],\n      // 防抖渲染计时器\n      renderTimer: null,\n      // 帧率控制\n      lastRenderTime: 0,\n      targetFPS: 30,\n      // 渲染计数，用于降低非必要渲染的频率\n      renderCount: 0,\n      // 动画相关\n      animationFrameId: null,\n      animationFrames: 0,\n      pulseDirection: 1,\n      pulseState: 0,\n      floatOffset: 0,\n      // 是否显示标签\n      showLabels: false,\n      // 记录前一次运行状态\n      previousIsRunning: false,\n      previousIsCaptured: false\n    };\n  },\n  mounted: function mounted() {\n    this.initCanvas();\n    // 初始化本地obstacles\n    this.localObstacles = Array.isArray(this.obstacles) ? _toConsumableArray(this.obstacles) : [];\n    this.drawSimulation();\n\n    // 添加窗口大小变化监听\n    window.addEventListener('resize', this.handleResize);\n\n    // 使用requestAnimationFrame实现高效渲染循环\n    this.startRenderLoop();\n  },\n  beforeDestroy: function beforeDestroy() {\n    // 清理事件监听器\n    window.removeEventListener('resize', this.handleResize);\n\n    // 停止渲染循环\n    this.stopRenderLoop();\n\n    // 清理计时器\n    if (this.renderTimer) {\n      clearTimeout(this.renderTimer);\n    }\n  },\n  methods: {\n    // 初始化画布\n    initCanvas: function initCanvas() {\n      this.canvas = this.$refs.canvas;\n      this.ctx = this.canvas.getContext('2d');\n      this.scale = this.canvasSize / this.environmentSize;\n\n      // 初始化previousPositions\n      this.updatePreviousPositions();\n    },\n    // 处理窗口大小变化\n    handleResize: function handleResize() {\n      var _this = this;\n      // 防抖处理\n      if (this.renderTimer) {\n        clearTimeout(this.renderTimer);\n      }\n      this.renderTimer = setTimeout(function () {\n        // 重新计算画布大小（可选，如果需要响应式调整画布大小）\n        // this.canvasSize = Math.min(window.innerWidth * 0.7, 600);\n        _this.scale = _this.canvasSize / _this.environmentSize;\n        _this.drawSimulation(true); // 强制完全重绘\n      }, 200);\n    },\n    // 启动渲染循环\n    startRenderLoop: function startRenderLoop() {\n      if (!this.animationFrameId) {\n        this.lastRenderTime = performance.now();\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\n      }\n    },\n    // 停止渲染循环\n    stopRenderLoop: function stopRenderLoop() {\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n    },\n    // 渲染循环\n    renderLoop: function renderLoop(timestamp) {\n      // 计算每帧的时间间隔\n      var elapsed = timestamp - this.lastRenderTime;\n      var frameTime = 1000 / this.targetFPS;\n\n      // 如果时间间隔足够，执行渲染\n      if (elapsed >= frameTime) {\n        this.lastRenderTime = timestamp;\n\n        // 更新动画状态\n        this.animationFrames++;\n        if (this.animationFrames % 3 === 0) {\n          // 每3帧更新一次动画状态\n          // 更新脉冲效果\n          this.pulseState += 0.05 * this.pulseDirection;\n          if (this.pulseState >= 1) {\n            this.pulseState = 1;\n            this.pulseDirection = -1;\n          } else if (this.pulseState <= 0) {\n            this.pulseState = 0;\n            this.pulseDirection = 1;\n          }\n\n          // 更新浮动效果\n          this.floatOffset += 0.1;\n        }\n\n        // 检查位置是否有变化，有变化时才渲染\n        if (this.hasPositionsChanged() || this.isRunning || this.animationFrames % 15 === 0) {\n          this.drawOptimizedSimulation();\n          this.updatePreviousPositions();\n        }\n      }\n\n      // 继续循环\n      this.animationFrameId = requestAnimationFrame(this.renderLoop);\n    },\n    // 检查位置是否有变化\n    hasPositionsChanged: function hasPositionsChanged() {\n      // 优化：快速检查数组长度变化\n      if (this.hunters.length !== this.previousPositions.hunters.length || this.targets.length !== this.previousPositions.targets.length) {\n        return true;\n      }\n\n      // 检查运行状态变化\n      if (this.isRunning !== this.previousIsRunning || this.isCaptured !== this.previousIsCaptured) {\n        this.previousIsRunning = this.isRunning;\n        this.previousIsCaptured = this.isCaptured;\n        return true;\n      }\n\n      // 渲染计数，每5帧强制完全重绘一次（避免累积误差）\n      this.renderCount++;\n      if (this.renderCount >= 5) {\n        this.renderCount = 0;\n        return true;\n      }\n\n      // 只有在运行中或首次渲染时，才进行位置变化检查\n      if (!this.isRunning && this.previousPositions.hunters.length > 0) {\n        return false;\n      }\n\n      // 智能体位置变化检测\n      var threshold = 0.5; // 位置变化阈值\n\n      // 检查猎手位置变化\n      for (var i = 0; i < this.hunters.length; i++) {\n        var hunter = this.hunters[i];\n        var prevHunter = this.previousPositions.hunters[i];\n        if (!prevHunter) return true;\n        if (Math.abs(hunter.position[0] - prevHunter.position[0]) > threshold || Math.abs(hunter.position[1] - prevHunter.position[1]) > threshold) {\n          return true;\n        }\n      }\n\n      // 检查目标位置变化\n      for (var _i = 0; _i < this.targets.length; _i++) {\n        var target = this.targets[_i];\n        var prevTarget = this.previousPositions.targets[_i];\n        if (!prevTarget) return true;\n        if (Math.abs(target.position[0] - prevTarget.position[0]) > threshold || Math.abs(target.position[1] - prevTarget.position[1]) > threshold) {\n          return true;\n        }\n      }\n      return false;\n    },\n    // 更新之前的位置\n    updatePreviousPositions: function updatePreviousPositions() {\n      // 深拷贝位置数据\n      this.previousPositions.hunters = this.hunters.map(function (hunter) {\n        return {\n          id: hunter.id,\n          position: _toConsumableArray(hunter.position)\n        };\n      });\n      this.previousPositions.targets = this.targets.map(function (target) {\n        return {\n          id: target.id,\n          position: _toConsumableArray(target.position)\n        };\n      });\n    },\n    // 优化的绘制方法\n    drawOptimizedSimulation: function drawOptimizedSimulation() {\n      var _this2 = this;\n      if (!this.ctx) return;\n\n      // 清除画布\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\n      this.drawBackground();\n\n      // 绘制环境边界\n      this.ctx.strokeStyle = '#ccc';\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\n\n      // 绘制障碍物 - 添加防御性检查\n      if (this.obstacles && Array.isArray(this.obstacles) && this.obstacles.length > 0) {\n        this.drawObstacles();\n      }\n\n      // 绘制捕获状态\n      if (this.isCaptured) {\n        this.ctx.fillStyle = this.colorMap.captured;\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n      }\n\n      // 绘制轨迹（如果启用）\n      if (this.showTrails) {\n        this.drawTrails();\n      }\n\n      // 绘制视野和通信范围（如果启用）\n      if (this.showVisionRange || this.showCommunicationRange) {\n        this.drawRanges();\n      }\n\n      // 绘制猎手\n      this.hunters.forEach(function (hunter) {\n        _this2.drawAgent(hunter, 'hunter');\n      });\n\n      // 绘制目标\n      this.targets.forEach(function (target) {\n        _this2.drawAgent(target, 'target');\n      });\n    },\n    // 绘制障碍物\n    drawObstacles: function drawObstacles() {\n      // 检查上下文是否已初始化\n      if (!this.ctx) {\n        console.error('画布上下文未初始化，无法绘制障碍物');\n        return;\n      }\n\n      // 检查本地障碍物数组的有效性\n      if (!this.localObstacles) {\n        console.warn('本地障碍物数组未初始化');\n        // 尝试从props中恢复\n        this.localObstacles = Array.isArray(this.obstacles) ? _toConsumableArray(this.obstacles) : [];\n      }\n\n      // 检查障碍物显示开关\n      if (!this.showObstacles) {\n        // 如果显示开关关闭，则跳过渲染\n        return;\n      }\n\n      // 检查障碍物数组是否有效且非空\n      if (!Array.isArray(this.localObstacles) || this.localObstacles.length === 0) {\n        console.warn('障碍物数组为空或格式不正确:', this.localObstacles);\n        return;\n      }\n      console.log(\"\\u6B63\\u5728\\u7ED8\\u5236\".concat(this.localObstacles.length, \"\\u4E2A\\u969C\\u788D\\u7269\"));\n\n      // 设置障碍物渲染样式\n      var baseColor = 'rgba(100, 100, 110, 0.8)';\n      var strokeColor = 'rgba(70, 70, 90, 1.0)';\n      var highlightColor = 'rgba(120, 120, 140, 0.6)';\n\n      // 遍历绘制每个障碍物\n      for (var i = 0; i < this.localObstacles.length; i++) {\n        var obstacle = this.localObstacles[i];\n\n        // 检查障碍物数据完整性\n        if (!obstacle) {\n          console.warn(\"\\u7B2C\".concat(i, \"\\u4E2A\\u969C\\u788D\\u7269\\u6570\\u636E\\u4E3A\\u7A7A\"));\n          continue;\n        }\n        if (!obstacle.position) {\n          console.warn(\"\\u7B2C\".concat(i, \"\\u4E2A\\u969C\\u788D\\u7269\\u7F3A\\u5C11\\u4F4D\\u7F6E\\u4FE1\\u606F:\"), obstacle);\n          continue;\n        }\n        if (!obstacle.radius || typeof obstacle.radius !== 'number' || obstacle.radius <= 0) {\n          console.warn(\"\\u7B2C\".concat(i, \"\\u4E2A\\u969C\\u788D\\u7269\\u534A\\u5F84\\u65E0\\u6548:\"), obstacle.radius);\n          continue;\n        }\n\n        // 处理位置信息 - 支持多种格式\n        var obstacleX = void 0,\n          obstacleY = void 0;\n        if (Array.isArray(obstacle.position)) {\n          // 数组格式 [x, y]\n          if (obstacle.position.length >= 2) {\n            var _obstacle$position = _slicedToArray(obstacle.position, 2);\n            obstacleX = _obstacle$position[0];\n            obstacleY = _obstacle$position[1];\n          } else {\n            console.warn(\"\\u7B2C\".concat(i, \"\\u4E2A\\u969C\\u788D\\u7269\\u4F4D\\u7F6E\\u6570\\u7EC4\\u683C\\u5F0F\\u9519\\u8BEF:\"), obstacle.position);\n            continue;\n          }\n        } else if (_typeof(obstacle.position) === 'object') {\n          // 对象格式 {x, y} 或 {0: x, 1: y}\n          if ('x' in obstacle.position && 'y' in obstacle.position) {\n            obstacleX = obstacle.position.x;\n            obstacleY = obstacle.position.y;\n          } else if ('0' in obstacle.position && '1' in obstacle.position) {\n            obstacleX = obstacle.position[0];\n            obstacleY = obstacle.position[1];\n          } else {\n            console.warn(\"\\u7B2C\".concat(i, \"\\u4E2A\\u969C\\u788D\\u7269\\u4F4D\\u7F6E\\u5BF9\\u8C61\\u683C\\u5F0F\\u9519\\u8BEF:\"), obstacle.position);\n            continue;\n          }\n        } else {\n          console.warn(\"\\u7B2C\".concat(i, \"\\u4E2A\\u969C\\u788D\\u7269\\u4F4D\\u7F6E\\u683C\\u5F0F\\u4E0D\\u652F\\u6301:\"), obstacle.position);\n          continue;\n        }\n\n        // 确保坐标为数字\n        if (isNaN(obstacleX) || isNaN(obstacleY)) {\n          console.warn(\"\\u7B2C\".concat(i, \"\\u4E2A\\u969C\\u788D\\u7269\\u5750\\u6807\\u542B\\u975E\\u6570\\u503C:\"), obstacleX, obstacleY);\n          continue;\n        }\n\n        // 转换坐标到画布坐标系\n        var pos = this.transformPosition([obstacleX, obstacleY]);\n        var radius = obstacle.radius * this.scale;\n\n        // 检查障碍物是否在画布范围内\n        if (pos.x + radius < 0 || pos.x - radius > this.canvasSize || pos.y + radius < 0 || pos.y - radius > this.canvasSize) {\n          console.warn(\"\\u7B2C\".concat(i, \"\\u4E2A\\u969C\\u788D\\u7269\\u5728\\u753B\\u5E03\\u8303\\u56F4\\u5916\\uFF0C\\u8DF3\\u8FC7\\u7ED8\\u5236\"));\n          continue;\n        }\n\n        // 绘制障碍物主体\n        this.ctx.beginPath();\n        this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\n\n        // 使用渐变填充增强视觉效果\n        var gradient = this.ctx.createRadialGradient(pos.x, pos.y, radius * 0.3, pos.x, pos.y, radius);\n        gradient.addColorStop(0, highlightColor);\n        gradient.addColorStop(1, baseColor);\n        this.ctx.fillStyle = gradient;\n        this.ctx.fill();\n\n        // 绘制边框\n        this.ctx.strokeStyle = strokeColor;\n        this.ctx.lineWidth = 2;\n        this.ctx.stroke();\n\n        // 可选：为每个障碍物添加编号，方便调试\n        if (this.showDebugInfo) {\n          this.ctx.fillStyle = 'white';\n          this.ctx.font = '10px Arial';\n          this.ctx.textAlign = 'center';\n          this.ctx.textBaseline = 'middle';\n          this.ctx.fillText(\"\".concat(i), pos.x, pos.y);\n        }\n      }\n    },\n    drawBackground: function drawBackground() {\n      var gridSize = 25 * this.scale;\n      var width = this.canvasSize;\n      var height = this.canvasSize;\n\n      // 填充背景色\n      this.ctx.fillStyle = '#f5f7fa';\n      this.ctx.fillRect(0, 0, width, height);\n      this.ctx.strokeStyle = 'rgba(200, 200, 220, 0.3)';\n      this.ctx.lineWidth = 1;\n\n      // 绘制网格线\n      for (var x = 0; x <= width; x += gridSize) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(x, 0);\n        this.ctx.lineTo(x, height);\n        this.ctx.stroke();\n      }\n      for (var y = 0; y <= height; y += gridSize) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(0, y);\n        this.ctx.lineTo(width, y);\n        this.ctx.stroke();\n      }\n\n      // 添加坐标轴\n      this.ctx.strokeStyle = 'rgba(150, 150, 180, 0.4)';\n      this.ctx.lineWidth = 2;\n\n      // x轴\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, height / 2);\n      this.ctx.lineTo(width, height / 2);\n      this.ctx.stroke();\n\n      // y轴\n      this.ctx.beginPath();\n      this.ctx.moveTo(width / 2, 0);\n      this.ctx.lineTo(width / 2, height);\n      this.ctx.stroke();\n    },\n    // 完整重绘方法\n    drawSimulation: function drawSimulation() {\n      var _this3 = this;\n      var forceFullRedraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (!this.ctx) return;\n\n      // 如果不需要强制重绘，使用优化版本\n      if (!forceFullRedraw && this.previousPositions.hunters.length > 0) {\n        return this.drawOptimizedSimulation();\n      }\n\n      // 清除画布\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\n      this.drawBackground();\n\n      // 绘制环境边界\n      this.ctx.strokeStyle = '#ccc';\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\n\n      // 绘制障碍物 - 添加防御性检查\n      if (this.obstacles && Array.isArray(this.obstacles) && this.obstacles.length > 0) {\n        this.drawObstacles();\n      }\n\n      // 绘制捕获状态\n      if (this.isCaptured) {\n        this.ctx.fillStyle = this.colorMap.captured;\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n      }\n\n      // 绘制轨迹（如果启用）\n      if (this.showTrails) {\n        this.drawTrails();\n      }\n\n      // 绘制视野和通信范围（如果启用）\n      if (this.showVisionRange || this.showCommunicationRange) {\n        this.drawRanges();\n      }\n\n      // 绘制猎手\n      this.hunters.forEach(function (hunter) {\n        _this3.drawAgent(hunter, 'hunter');\n      });\n\n      // 绘制目标\n      this.targets.forEach(function (target) {\n        _this3.drawAgent(target, 'target');\n      });\n\n      // 更新之前的位置\n      this.updatePreviousPositions();\n      this.previousIsRunning = this.isRunning;\n      this.previousIsCaptured = this.isCaptured;\n    },\n    // 单独绘制轨迹\n    drawTrails: function drawTrails() {\n      var _this4 = this;\n      // 绘制猎手轨迹\n      this.hunters.forEach(function (hunter) {\n        if (hunter.history && hunter.history.length > 1) {\n          _this4.ctx.beginPath();\n          var startPos = _this4.transformPosition(hunter.history[0]);\n          _this4.ctx.moveTo(startPos.x, startPos.y);\n          for (var i = 1; i < hunter.history.length; i++) {\n            var histPos = _this4.transformPosition(hunter.history[i]);\n            _this4.ctx.lineTo(histPos.x, histPos.y);\n          }\n          _this4.ctx.strokeStyle = _this4.colorMap.trail;\n          _this4.ctx.lineWidth = 1.5;\n          _this4.ctx.stroke();\n        }\n      });\n\n      // 绘制目标轨迹\n      this.targets.forEach(function (target) {\n        if (target.history && target.history.length > 1) {\n          _this4.ctx.beginPath();\n          var startPos = _this4.transformPosition(target.history[0]);\n          _this4.ctx.moveTo(startPos.x, startPos.y);\n          for (var i = 1; i < target.history.length; i++) {\n            var histPos = _this4.transformPosition(target.history[i]);\n            _this4.ctx.lineTo(histPos.x, histPos.y);\n          }\n          _this4.ctx.strokeStyle = _this4.colorMap.target;\n          _this4.ctx.lineWidth = 1.5;\n          _this4.ctx.stroke();\n        }\n      });\n    },\n    // 单独绘制视野和通信范围\n    drawRanges: function drawRanges() {\n      var _this5 = this;\n      // 绘制猎手视野和通信范围\n      this.hunters.forEach(function (hunter) {\n        var pos = _this5.transformPosition(hunter.position);\n\n        // 绘制视野范围\n        if (_this5.showVisionRange) {\n          _this5.ctx.beginPath();\n          _this5.ctx.arc(pos.x, pos.y, hunter.vision_range * _this5.scale, 0, Math.PI * 2);\n          _this5.ctx.fillStyle = _this5.colorMap.vision;\n          _this5.ctx.fill();\n        }\n\n        // 绘制通信范围\n        if (_this5.showCommunicationRange) {\n          _this5.ctx.beginPath();\n          _this5.ctx.arc(pos.x, pos.y, hunter.communication_range * _this5.scale, 0, Math.PI * 2);\n          _this5.ctx.fillStyle = _this5.colorMap.communication;\n          _this5.ctx.fill();\n        }\n\n        // 绘制捕获范围\n        _this5.ctx.beginPath();\n        _this5.ctx.arc(pos.x, pos.y, 10 * _this5.scale, 0, Math.PI * 2); // 捕获范围固定为10\n        _this5.ctx.fillStyle = _this5.colorMap.captureRange;\n        _this5.ctx.fill();\n      });\n\n      // 绘制目标视野范围\n      this.targets.forEach(function (target) {\n        if (_this5.showVisionRange) {\n          var pos = _this5.transformPosition(target.position);\n          _this5.ctx.beginPath();\n          _this5.ctx.arc(pos.x, pos.y, target.vision_range * _this5.scale, 0, Math.PI * 2);\n          _this5.ctx.fillStyle = 'rgba(244, 67, 54, 0.1)'; // 半透明红色\n          _this5.ctx.fill();\n        }\n      });\n    },\n    // 绘制智能体\n    drawAgent: function drawAgent(agent, type) {\n      var pos = this.transformPosition(agent.position);\n\n      // 目标的浮动动画\n      var offsetY = 0;\n      if (type === 'target') {\n        offsetY = Math.sin(this.floatOffset) * 3; // 浮动效果\n        this.drawCaptureRadius(pos, offsetY);\n      }\n\n      // 绘制智能体\n      this.ctx.beginPath();\n      var radius = type === 'hunter' ? 6 : 8; // 稍微增大智能体尺寸\n      this.ctx.arc(pos.x, pos.y + offsetY, radius, 0, Math.PI * 2);\n      this.ctx.fillStyle = this.colorMap[type];\n      this.ctx.fill();\n\n      // 添加发光效果\n      this.ctx.shadowColor = type === 'hunter' ? 'rgba(63, 81, 181, 0.5)' : 'rgba(244, 67, 54, 0.5)';\n      this.ctx.shadowBlur = 10;\n      this.ctx.stroke();\n      this.ctx.shadowBlur = 0; // 重置阴影效果\n\n      // 绘制ID标签（可选，使UI更干净）\n      if (this.showLabels) {\n        // 使用配置选项\n        this.ctx.font = '10px Arial';\n        this.ctx.fillStyle = '#000';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(agent.id.toString(), pos.x, pos.y + offsetY + (type === 'hunter' ? 15 : 20));\n      }\n    },\n    // 新增方法：绘制目标捕获半径\n    drawCaptureRadius: function drawCaptureRadius(pos, offsetY) {\n      var pulseScale = 1 + this.pulseState * 0.15; // 脉冲效果，范围是1.0到1.15\n\n      this.ctx.beginPath();\n      this.ctx.arc(pos.x, pos.y + offsetY, 30 * pulseScale, 0, Math.PI * 2);\n      this.ctx.strokeStyle = 'rgba(76, 175, 80, 0.6)';\n      this.ctx.setLineDash([5, 3]); // 虚线效果\n      this.ctx.lineWidth = 1.5;\n      this.ctx.stroke();\n      this.ctx.setLineDash([]); // 重置线型\n    },\n    // 转换坐标\n    transformPosition: function transformPosition(position) {\n      // 将模拟坐标转换为画布坐标\n      return {\n        x: position[0] * this.scale,\n        y: position[1] * this.scale\n      };\n    },\n    // 清除特定区域\n    clearAgentArea: function clearAgentArea(position) {\n      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n      var pos = this.transformPosition(position);\n      this.ctx.clearRect(pos.x - radius, pos.y - radius, radius * 2, radius * 2);\n    }\n  },\n  watch: {\n    hunters: {\n      handler: function handler() {\n        var _this6 = this;\n        // 使用防抖处理，避免频繁重绘\n        if (this.renderTimer) {\n          clearTimeout(this.renderTimer);\n        }\n        this.renderTimer = setTimeout(function () {\n          _this6.drawOptimizedSimulation();\n        }, 50);\n      },\n      deep: true\n    },\n    targets: {\n      handler: function handler() {\n        var _this7 = this;\n        // 使用防抖处理，避免频繁重绘\n        if (this.renderTimer) {\n          clearTimeout(this.renderTimer);\n        }\n        this.renderTimer = setTimeout(function () {\n          _this7.drawOptimizedSimulation();\n        }, 50);\n      },\n      deep: true\n    },\n    // 添加对obstacles的监听，添加防御性检查\n    obstacles: {\n      handler: function handler(newObstacles) {\n        console.log('obstacles属性变化:', newObstacles);\n        if (newObstacles === null || newObstacles === undefined) {\n          this.localObstacles = [];\n          console.warn('收到null/undefined障碍物数据');\n        } else if (Array.isArray(newObstacles)) {\n          this.localObstacles = _toConsumableArray(newObstacles);\n          console.log(\"\\u66F4\\u65B0\\u672C\\u5730\\u969C\\u788D\\u7269\\u6570\\u636E(\".concat(this.localObstacles.length, \"\\u4E2A)\"));\n        } else {\n          console.error('收到非数组障碍物数据:', newObstacles);\n          this.localObstacles = [];\n        }\n\n        // 强制重绘以确保障碍物显示\n        this.drawSimulation(true);\n      },\n      deep: true,\n      immediate: true // 确保组件挂载时立即触发\n    },\n    isRunning: function isRunning(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    isCaptured: function isCaptured(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    showTrails: function showTrails(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    showVisionRange: function showVisionRange(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    showCommunicationRange: function showCommunicationRange(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    environmentSize: function environmentSize() {\n      this.scale = this.canvasSize / this.environmentSize;\n      this.drawSimulation(true); // 强制完全重绘\n    }\n  }\n};","map":{"version":3,"names":["name","props","hunters","type","Array","required","targets","environmentSize","Number","isRunning","Boolean","isCaptured","showTrails","showVisionRange","showCommunicationRange","obstacles","default","data","canvasSize","canvas","ctx","scale","colorMap","hunter","target","vision","communication","trail","captureRange","captured","obstacle","previousPositions","localObstacles","renderTimer","lastRenderTime","targetFPS","renderCount","animationFrameId","animationFrames","pulseDirection","pulseState","floatOffset","showLabels","previousIsRunning","previousIsCaptured","mounted","initCanvas","isArray","_toConsumableArray","drawSimulation","window","addEventListener","handleResize","startRenderLoop","beforeDestroy","removeEventListener","stopRenderLoop","clearTimeout","methods","$refs","getContext","updatePreviousPositions","_this","setTimeout","performance","now","requestAnimationFrame","renderLoop","cancelAnimationFrame","timestamp","elapsed","frameTime","hasPositionsChanged","drawOptimizedSimulation","length","threshold","i","prevHunter","Math","abs","position","prevTarget","map","id","_this2","clearRect","drawBackground","strokeStyle","lineWidth","strokeRect","drawObstacles","fillStyle","fillRect","drawTrails","drawRanges","forEach","drawAgent","console","error","warn","showObstacles","log","concat","baseColor","strokeColor","highlightColor","radius","obstacleX","obstacleY","_obstacle$position","_slicedToArray","_typeof","x","y","isNaN","pos","transformPosition","beginPath","arc","PI","gradient","createRadialGradient","addColorStop","fill","stroke","showDebugInfo","font","textAlign","textBaseline","fillText","gridSize","width","height","moveTo","lineTo","_this3","forceFullRedraw","arguments","undefined","_this4","history","startPos","histPos","_this5","vision_range","communication_range","agent","offsetY","sin","drawCaptureRadius","shadowColor","shadowBlur","toString","pulseScale","setLineDash","clearAgentArea","watch","handler","_this6","deep","_this7","newObstacles","immediate","newVal","oldVal"],"sources":["src/components/SimulationCanvas.vue"],"sourcesContent":["<template>\r\n  <div class=\"simulation-canvas\">\r\n    <canvas \r\n      ref=\"canvas\" \r\n      :width=\"canvasSize\" \r\n      :height=\"canvasSize\" \r\n      class=\"simulation-canvas__area\"\r\n    ></canvas>\r\n    \r\n    <!-- 捕获成功提示覆盖层 -->\r\n    <div \r\n      v-if=\"isCaptured\" \r\n      class=\"capture-overlay\"\r\n    >\r\n      <div class=\"capture-message\">\r\n        <v-icon large color=\"success\">mdi-check-circle</v-icon>\r\n        <span>目标已捕获!</span>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nexport default {\r\n  name: 'SimulationCanvas',\r\n  props: {\r\n    hunters: {\r\n      type: Array,\r\n      required: true\r\n    },\r\n    targets: {\r\n      type: Array,\r\n      required: true\r\n    },\r\n    environmentSize: {\r\n      type: Number,\r\n      default: 500\r\n    },\r\n    isRunning: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    isCaptured: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    showTrails: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    showVisionRange: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    showCommunicationRange: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    obstacles: {\r\n      type: Array,\r\n      default: () => [] // 确保默认为空数组\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      canvasSize: 600,\r\n      canvas: null,\r\n      ctx: null,\r\n      scale: 1,\r\n      colorMap: {\r\n        hunter: '#3949AB', // 更深的蓝色\r\n        target: '#e53935', // 更鲜艳的红色\r\n        vision: 'rgba(57, 73, 171, 0.1)', // 半透明蓝色\r\n        communication: 'rgba(57, 73, 171, 0.05)', // 更透明的蓝色\r\n        trail: 'rgba(57, 73, 171, 0.4)', // 半透明蓝色\r\n        captureRange: 'rgba(76, 175, 80, 0.4)', // 更明显的绿色\r\n        captured: 'rgba(244, 67, 54, 0.25)', // 半透明红色\r\n        obstacle: 'rgba(100, 100, 110, 0.8)' // 障碍物颜色\r\n      },\r\n      // 新增：跟踪之前的位置，用于优化渲染\r\n      previousPositions: {\r\n        hunters: [],\r\n        targets: []\r\n      },\r\n      // 本地obstacles引用，防止未定义错误\r\n      localObstacles: [],\r\n      // 防抖渲染计时器\r\n      renderTimer: null,\r\n      // 帧率控制\r\n      lastRenderTime: 0,\r\n      targetFPS: 30,\r\n      // 渲染计数，用于降低非必要渲染的频率\r\n      renderCount: 0,\r\n      // 动画相关\r\n      animationFrameId: null,\r\n      animationFrames: 0,\r\n      pulseDirection: 1,\r\n      pulseState: 0,\r\n      floatOffset: 0,\r\n      // 是否显示标签\r\n      showLabels: false,\r\n      // 记录前一次运行状态\r\n      previousIsRunning: false,\r\n      previousIsCaptured: false\r\n    };\r\n  },\r\n  mounted() {\r\n    this.initCanvas();\r\n    // 初始化本地obstacles\r\n    this.localObstacles = Array.isArray(this.obstacles) ? [...this.obstacles] : [];\r\n    this.drawSimulation();\r\n    \r\n    // 添加窗口大小变化监听\r\n    window.addEventListener('resize', this.handleResize);\r\n    \r\n    // 使用requestAnimationFrame实现高效渲染循环\r\n    this.startRenderLoop();\r\n  },\r\n  beforeDestroy() {\r\n    // 清理事件监听器\r\n    window.removeEventListener('resize', this.handleResize);\r\n    \r\n    // 停止渲染循环\r\n    this.stopRenderLoop();\r\n    \r\n    // 清理计时器\r\n    if (this.renderTimer) {\r\n      clearTimeout(this.renderTimer);\r\n    }\r\n  },\r\n  methods: {\r\n    // 初始化画布\r\n    initCanvas() {\r\n      this.canvas = this.$refs.canvas;\r\n      this.ctx = this.canvas.getContext('2d');\r\n      this.scale = this.canvasSize / this.environmentSize;\r\n      \r\n      // 初始化previousPositions\r\n      this.updatePreviousPositions();\r\n    },\r\n    \r\n    // 处理窗口大小变化\r\n    handleResize() {\r\n      // 防抖处理\r\n      if (this.renderTimer) {\r\n        clearTimeout(this.renderTimer);\r\n      }\r\n      \r\n      this.renderTimer = setTimeout(() => {\r\n        // 重新计算画布大小（可选，如果需要响应式调整画布大小）\r\n        // this.canvasSize = Math.min(window.innerWidth * 0.7, 600);\r\n        this.scale = this.canvasSize / this.environmentSize;\r\n        this.drawSimulation(true); // 强制完全重绘\r\n      }, 200);\r\n    },\r\n    \r\n    // 启动渲染循环\r\n    startRenderLoop() {\r\n      if (!this.animationFrameId) {\r\n        this.lastRenderTime = performance.now();\r\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\r\n      }\r\n    },\r\n    \r\n    // 停止渲染循环\r\n    stopRenderLoop() {\r\n      if (this.animationFrameId) {\r\n        cancelAnimationFrame(this.animationFrameId);\r\n        this.animationFrameId = null;\r\n      }\r\n    },\r\n    \r\n    // 渲染循环\r\n    renderLoop(timestamp) {\r\n      // 计算每帧的时间间隔\r\n      const elapsed = timestamp - this.lastRenderTime;\r\n      const frameTime = 1000 / this.targetFPS;\r\n      \r\n      // 如果时间间隔足够，执行渲染\r\n      if (elapsed >= frameTime) {\r\n        this.lastRenderTime = timestamp;\r\n        \r\n        // 更新动画状态\r\n        this.animationFrames++;\r\n        if (this.animationFrames % 3 === 0) { // 每3帧更新一次动画状态\r\n          // 更新脉冲效果\r\n          this.pulseState += 0.05 * this.pulseDirection;\r\n          if (this.pulseState >= 1) {\r\n            this.pulseState = 1;\r\n            this.pulseDirection = -1;\r\n          } else if (this.pulseState <= 0) {\r\n            this.pulseState = 0;\r\n            this.pulseDirection = 1;\r\n          }\r\n          \r\n          // 更新浮动效果\r\n          this.floatOffset += 0.1;\r\n        }\r\n        \r\n        // 检查位置是否有变化，有变化时才渲染\r\n        if (this.hasPositionsChanged() || this.isRunning || this.animationFrames % 15 === 0) {\r\n          this.drawOptimizedSimulation();\r\n          this.updatePreviousPositions();\r\n        }\r\n      }\r\n      \r\n      // 继续循环\r\n      this.animationFrameId = requestAnimationFrame(this.renderLoop);\r\n    },\r\n    \r\n    // 检查位置是否有变化\r\n    hasPositionsChanged() {\r\n      // 优化：快速检查数组长度变化\r\n      if (this.hunters.length !== this.previousPositions.hunters.length ||\r\n          this.targets.length !== this.previousPositions.targets.length) {\r\n        return true;\r\n      }\r\n      \r\n      // 检查运行状态变化\r\n      if (this.isRunning !== this.previousIsRunning ||\r\n          this.isCaptured !== this.previousIsCaptured) {\r\n        this.previousIsRunning = this.isRunning;\r\n        this.previousIsCaptured = this.isCaptured;\r\n        return true;\r\n      }\r\n      \r\n      // 渲染计数，每5帧强制完全重绘一次（避免累积误差）\r\n      this.renderCount++;\r\n      if (this.renderCount >= 5) {\r\n        this.renderCount = 0;\r\n        return true;\r\n      }\r\n      \r\n      // 只有在运行中或首次渲染时，才进行位置变化检查\r\n      if (!this.isRunning && this.previousPositions.hunters.length > 0) {\r\n        return false;\r\n      }\r\n      \r\n      // 智能体位置变化检测\r\n      const threshold = 0.5; // 位置变化阈值\r\n      \r\n      // 检查猎手位置变化\r\n      for (let i = 0; i < this.hunters.length; i++) {\r\n        const hunter = this.hunters[i];\r\n        const prevHunter = this.previousPositions.hunters[i];\r\n        \r\n        if (!prevHunter) return true;\r\n        \r\n        if (Math.abs(hunter.position[0] - prevHunter.position[0]) > threshold ||\r\n            Math.abs(hunter.position[1] - prevHunter.position[1]) > threshold) {\r\n          return true;\r\n        }\r\n      }\r\n      \r\n      // 检查目标位置变化\r\n      for (let i = 0; i < this.targets.length; i++) {\r\n        const target = this.targets[i];\r\n        const prevTarget = this.previousPositions.targets[i];\r\n        \r\n        if (!prevTarget) return true;\r\n        \r\n        if (Math.abs(target.position[0] - prevTarget.position[0]) > threshold ||\r\n            Math.abs(target.position[1] - prevTarget.position[1]) > threshold) {\r\n          return true;\r\n        }\r\n      }\r\n      \r\n      return false;\r\n    },\r\n    \r\n    // 更新之前的位置\r\n    updatePreviousPositions() {\r\n      // 深拷贝位置数据\r\n      this.previousPositions.hunters = this.hunters.map(hunter => ({\r\n        id: hunter.id,\r\n        position: [...hunter.position]\r\n      }));\r\n      \r\n      this.previousPositions.targets = this.targets.map(target => ({\r\n        id: target.id,\r\n        position: [...target.position]\r\n      }));\r\n    },\r\n    \r\n    // 优化的绘制方法\r\n    drawOptimizedSimulation() {\r\n      if (!this.ctx) return;\r\n      \r\n      // 清除画布\r\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\r\n\r\n      this.drawBackground();\r\n      \r\n      // 绘制环境边界\r\n      this.ctx.strokeStyle = '#ccc';\r\n      this.ctx.lineWidth = 2;\r\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\r\n      \r\n      // 绘制障碍物 - 添加防御性检查\r\n      if (this.obstacles && Array.isArray(this.obstacles) && this.obstacles.length > 0) {\r\n        this.drawObstacles();\r\n      }\r\n      \r\n      // 绘制捕获状态\r\n      if (this.isCaptured) {\r\n        this.ctx.fillStyle = this.colorMap.captured;\r\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n      }\r\n      \r\n      // 绘制轨迹（如果启用）\r\n      if (this.showTrails) {\r\n        this.drawTrails();\r\n      }\r\n      \r\n      // 绘制视野和通信范围（如果启用）\r\n      if (this.showVisionRange || this.showCommunicationRange) {\r\n        this.drawRanges();\r\n      }\r\n      \r\n      // 绘制猎手\r\n      this.hunters.forEach(hunter => {\r\n        this.drawAgent(hunter, 'hunter');\r\n      });\r\n      \r\n      // 绘制目标\r\n      this.targets.forEach(target => {\r\n        this.drawAgent(target, 'target');\r\n      });\r\n    },\r\n    \r\n    // 绘制障碍物\r\n    drawObstacles() {\r\n      // 检查上下文是否已初始化\r\n      if (!this.ctx) {\r\n        console.error('画布上下文未初始化，无法绘制障碍物');\r\n        return;\r\n      }\r\n\r\n      // 检查本地障碍物数组的有效性\r\n      if (!this.localObstacles) {\r\n        console.warn('本地障碍物数组未初始化');\r\n        // 尝试从props中恢复\r\n        this.localObstacles = Array.isArray(this.obstacles) ? [...this.obstacles] : [];\r\n      }\r\n\r\n      // 检查障碍物显示开关\r\n      if (!this.showObstacles) {\r\n        // 如果显示开关关闭，则跳过渲染\r\n        return;\r\n      }\r\n\r\n      // 检查障碍物数组是否有效且非空\r\n      if (!Array.isArray(this.localObstacles) || this.localObstacles.length === 0) {\r\n        console.warn('障碍物数组为空或格式不正确:', this.localObstacles);\r\n        return;\r\n      }\r\n\r\n      console.log(`正在绘制${this.localObstacles.length}个障碍物`);\r\n\r\n      // 设置障碍物渲染样式\r\n      const baseColor = 'rgba(100, 100, 110, 0.8)';\r\n      const strokeColor = 'rgba(70, 70, 90, 1.0)';\r\n      const highlightColor = 'rgba(120, 120, 140, 0.6)';\r\n\r\n      // 遍历绘制每个障碍物\r\n      for (let i = 0; i < this.localObstacles.length; i++) {\r\n        const obstacle = this.localObstacles[i];\r\n        \r\n        // 检查障碍物数据完整性\r\n        if (!obstacle) {\r\n          console.warn(`第${i}个障碍物数据为空`);\r\n          continue;\r\n        }\r\n\r\n        if (!obstacle.position) {\r\n          console.warn(`第${i}个障碍物缺少位置信息:`, obstacle);\r\n          continue;\r\n        }\r\n\r\n        if (!obstacle.radius || typeof obstacle.radius !== 'number' || obstacle.radius <= 0) {\r\n          console.warn(`第${i}个障碍物半径无效:`, obstacle.radius);\r\n          continue;\r\n        }\r\n\r\n        // 处理位置信息 - 支持多种格式\r\n        let obstacleX, obstacleY;\r\n        if (Array.isArray(obstacle.position)) {\r\n          // 数组格式 [x, y]\r\n          if (obstacle.position.length >= 2) {\r\n            [obstacleX, obstacleY] = obstacle.position;\r\n          } else {\r\n            console.warn(`第${i}个障碍物位置数组格式错误:`, obstacle.position);\r\n            continue;\r\n          }\r\n        } else if (typeof obstacle.position === 'object') {\r\n          // 对象格式 {x, y} 或 {0: x, 1: y}\r\n          if ('x' in obstacle.position && 'y' in obstacle.position) {\r\n            obstacleX = obstacle.position.x;\r\n            obstacleY = obstacle.position.y;\r\n          } else if ('0' in obstacle.position && '1' in obstacle.position) {\r\n            obstacleX = obstacle.position[0];\r\n            obstacleY = obstacle.position[1];\r\n          } else {\r\n            console.warn(`第${i}个障碍物位置对象格式错误:`, obstacle.position);\r\n            continue;\r\n          }\r\n        } else {\r\n          console.warn(`第${i}个障碍物位置格式不支持:`, obstacle.position);\r\n          continue;\r\n        }\r\n\r\n        // 确保坐标为数字\r\n        if (isNaN(obstacleX) || isNaN(obstacleY)) {\r\n          console.warn(`第${i}个障碍物坐标含非数值:`, obstacleX, obstacleY);\r\n          continue;\r\n        }\r\n\r\n        // 转换坐标到画布坐标系\r\n        const pos = this.transformPosition([obstacleX, obstacleY]);\r\n        const radius = obstacle.radius * this.scale;\r\n\r\n        // 检查障碍物是否在画布范围内\r\n        if (pos.x + radius < 0 || pos.x - radius > this.canvasSize || \r\n            pos.y + radius < 0 || pos.y - radius > this.canvasSize) {\r\n          console.warn(`第${i}个障碍物在画布范围外，跳过绘制`);\r\n          continue;\r\n        }\r\n\r\n        // 绘制障碍物主体\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\r\n        \r\n        // 使用渐变填充增强视觉效果\r\n        const gradient = this.ctx.createRadialGradient(\r\n          pos.x, pos.y, radius * 0.3,\r\n          pos.x, pos.y, radius\r\n        );\r\n        gradient.addColorStop(0, highlightColor);\r\n        gradient.addColorStop(1, baseColor);\r\n        this.ctx.fillStyle = gradient;\r\n        this.ctx.fill();\r\n        \r\n        // 绘制边框\r\n        this.ctx.strokeStyle = strokeColor;\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.stroke();\r\n\r\n        // 可选：为每个障碍物添加编号，方便调试\r\n        if (this.showDebugInfo) {\r\n          this.ctx.fillStyle = 'white';\r\n          this.ctx.font = '10px Arial';\r\n          this.ctx.textAlign = 'center';\r\n          this.ctx.textBaseline = 'middle';\r\n          this.ctx.fillText(`${i}`, pos.x, pos.y);\r\n        }\r\n      }\r\n    },\r\n\r\n    drawBackground() {\r\n      const gridSize = 25 * this.scale;\r\n      const width = this.canvasSize;\r\n      const height = this.canvasSize;\r\n      \r\n      // 填充背景色\r\n      this.ctx.fillStyle = '#f5f7fa';\r\n      this.ctx.fillRect(0, 0, width, height);\r\n      \r\n      this.ctx.strokeStyle = 'rgba(200, 200, 220, 0.3)';\r\n      this.ctx.lineWidth = 1;\r\n      \r\n      // 绘制网格线\r\n      for (let x = 0; x <= width; x += gridSize) {\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(x, 0);\r\n        this.ctx.lineTo(x, height);\r\n        this.ctx.stroke();\r\n      }\r\n      \r\n      for (let y = 0; y <= height; y += gridSize) {\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(0, y);\r\n        this.ctx.lineTo(width, y);\r\n        this.ctx.stroke();\r\n      }\r\n      \r\n      // 添加坐标轴\r\n      this.ctx.strokeStyle = 'rgba(150, 150, 180, 0.4)';\r\n      this.ctx.lineWidth = 2;\r\n      \r\n      // x轴\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(0, height/2);\r\n      this.ctx.lineTo(width, height/2);\r\n      this.ctx.stroke();\r\n      \r\n      // y轴\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(width/2, 0);\r\n      this.ctx.lineTo(width/2, height);\r\n      this.ctx.stroke();\r\n    },\r\n    \r\n    // 完整重绘方法\r\n    drawSimulation(forceFullRedraw = false) {\r\n      if (!this.ctx) return;\r\n      \r\n      // 如果不需要强制重绘，使用优化版本\r\n      if (!forceFullRedraw && this.previousPositions.hunters.length > 0) {\r\n        return this.drawOptimizedSimulation();\r\n      }\r\n      \r\n      // 清除画布\r\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\r\n\r\n      this.drawBackground();\r\n      \r\n      // 绘制环境边界\r\n      this.ctx.strokeStyle = '#ccc';\r\n      this.ctx.lineWidth = 2;\r\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\r\n      \r\n      // 绘制障碍物 - 添加防御性检查\r\n      if (this.obstacles && Array.isArray(this.obstacles) && this.obstacles.length > 0) {\r\n        this.drawObstacles();\r\n      }\r\n      \r\n      // 绘制捕获状态\r\n      if (this.isCaptured) {\r\n        this.ctx.fillStyle = this.colorMap.captured;\r\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n      }\r\n      \r\n      // 绘制轨迹（如果启用）\r\n      if (this.showTrails) {\r\n        this.drawTrails();\r\n      }\r\n      \r\n      // 绘制视野和通信范围（如果启用）\r\n      if (this.showVisionRange || this.showCommunicationRange) {\r\n        this.drawRanges();\r\n      }\r\n      \r\n      // 绘制猎手\r\n      this.hunters.forEach(hunter => {\r\n        this.drawAgent(hunter, 'hunter');\r\n      });\r\n      \r\n      // 绘制目标\r\n      this.targets.forEach(target => {\r\n        this.drawAgent(target, 'target');\r\n      });\r\n      \r\n      // 更新之前的位置\r\n      this.updatePreviousPositions();\r\n      this.previousIsRunning = this.isRunning;\r\n      this.previousIsCaptured = this.isCaptured;\r\n    },\r\n    \r\n    // 单独绘制轨迹\r\n    drawTrails() {\r\n      // 绘制猎手轨迹\r\n      this.hunters.forEach(hunter => {\r\n        if (hunter.history && hunter.history.length > 1) {\r\n          this.ctx.beginPath();\r\n          const startPos = this.transformPosition(hunter.history[0]);\r\n          this.ctx.moveTo(startPos.x, startPos.y);\r\n          \r\n          for (let i = 1; i < hunter.history.length; i++) {\r\n            const histPos = this.transformPosition(hunter.history[i]);\r\n            this.ctx.lineTo(histPos.x, histPos.y);\r\n          }\r\n          \r\n          this.ctx.strokeStyle = this.colorMap.trail;\r\n          this.ctx.lineWidth = 1.5;\r\n          this.ctx.stroke();\r\n        }\r\n      });\r\n      \r\n      // 绘制目标轨迹\r\n      this.targets.forEach(target => {\r\n        if (target.history && target.history.length > 1) {\r\n          this.ctx.beginPath();\r\n          const startPos = this.transformPosition(target.history[0]);\r\n          this.ctx.moveTo(startPos.x, startPos.y);\r\n          \r\n          for (let i = 1; i < target.history.length; i++) {\r\n            const histPos = this.transformPosition(target.history[i]);\r\n            this.ctx.lineTo(histPos.x, histPos.y);\r\n          }\r\n          \r\n          this.ctx.strokeStyle = this.colorMap.target;\r\n          this.ctx.lineWidth = 1.5;\r\n          this.ctx.stroke();\r\n        }\r\n      });\r\n    },\r\n    \r\n    // 单独绘制视野和通信范围\r\n    drawRanges() {\r\n      // 绘制猎手视野和通信范围\r\n      this.hunters.forEach(hunter => {\r\n        const pos = this.transformPosition(hunter.position);\r\n        \r\n        // 绘制视野范围\r\n        if (this.showVisionRange) {\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, hunter.vision_range * this.scale, 0, Math.PI * 2);\r\n          this.ctx.fillStyle = this.colorMap.vision;\r\n          this.ctx.fill();\r\n        }\r\n        \r\n        // 绘制通信范围\r\n        if (this.showCommunicationRange) {\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, hunter.communication_range * this.scale, 0, Math.PI * 2);\r\n          this.ctx.fillStyle = this.colorMap.communication;\r\n          this.ctx.fill();\r\n        }\r\n        \r\n        // 绘制捕获范围\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(pos.x, pos.y, 10 * this.scale, 0, Math.PI * 2); // 捕获范围固定为10\r\n        this.ctx.fillStyle = this.colorMap.captureRange;\r\n        this.ctx.fill();\r\n      });\r\n      \r\n      // 绘制目标视野范围\r\n      this.targets.forEach(target => {\r\n        if (this.showVisionRange) {\r\n          const pos = this.transformPosition(target.position);\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, target.vision_range * this.scale, 0, Math.PI * 2);\r\n          this.ctx.fillStyle = 'rgba(244, 67, 54, 0.1)'; // 半透明红色\r\n          this.ctx.fill();\r\n        }\r\n      });\r\n    },\r\n    \r\n    // 绘制智能体\r\n    drawAgent(agent, type) {\r\n      const pos = this.transformPosition(agent.position);\r\n      \r\n      // 目标的浮动动画\r\n      let offsetY = 0;\r\n      if (type === 'target') {\r\n        offsetY = Math.sin(this.floatOffset) * 3; // 浮动效果\r\n        this.drawCaptureRadius(pos, offsetY);\r\n      }\r\n      \r\n      // 绘制智能体\r\n      this.ctx.beginPath();\r\n      const radius = type === 'hunter' ? 6 : 8; // 稍微增大智能体尺寸\r\n      this.ctx.arc(pos.x, pos.y + offsetY, radius, 0, Math.PI * 2);\r\n      this.ctx.fillStyle = this.colorMap[type];\r\n      this.ctx.fill();\r\n      \r\n      // 添加发光效果\r\n      this.ctx.shadowColor = type === 'hunter' ? 'rgba(63, 81, 181, 0.5)' : 'rgba(244, 67, 54, 0.5)';\r\n      this.ctx.shadowBlur = 10;\r\n      this.ctx.stroke();\r\n      this.ctx.shadowBlur = 0; // 重置阴影效果\r\n      \r\n      // 绘制ID标签（可选，使UI更干净）\r\n      if (this.showLabels) { // 使用配置选项\r\n        this.ctx.font = '10px Arial';\r\n        this.ctx.fillStyle = '#000';\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.fillText(agent.id.toString(), pos.x, pos.y + offsetY + (type === 'hunter' ? 15 : 20));\r\n      }\r\n    },\r\n    \r\n    // 新增方法：绘制目标捕获半径\r\n    drawCaptureRadius(pos, offsetY) {\r\n      const pulseScale = 1 + (this.pulseState * 0.15); // 脉冲效果，范围是1.0到1.15\r\n      \r\n      this.ctx.beginPath();\r\n      this.ctx.arc(pos.x, pos.y + offsetY, 30 * pulseScale, 0, Math.PI * 2);\r\n      this.ctx.strokeStyle = 'rgba(76, 175, 80, 0.6)';\r\n      this.ctx.setLineDash([5, 3]); // 虚线效果\r\n      this.ctx.lineWidth = 1.5;\r\n      this.ctx.stroke();\r\n      this.ctx.setLineDash([]); // 重置线型\r\n    },\r\n    \r\n    // 转换坐标\r\n    transformPosition(position) {\r\n      // 将模拟坐标转换为画布坐标\r\n      return {\r\n        x: position[0] * this.scale,\r\n        y: position[1] * this.scale\r\n      }\r\n    },\r\n    \r\n    // 清除特定区域\r\n    clearAgentArea(position, radius = 20) {\r\n      const pos = this.transformPosition(position);\r\n      this.ctx.clearRect(pos.x - radius, pos.y - radius, radius * 2, radius * 2);\r\n    }\r\n  },\r\n  watch: {\r\n    hunters: {\r\n      handler() {\r\n        // 使用防抖处理，避免频繁重绘\r\n        if (this.renderTimer) {\r\n          clearTimeout(this.renderTimer);\r\n        }\r\n        this.renderTimer = setTimeout(() => {\r\n          this.drawOptimizedSimulation();\r\n        }, 50);\r\n      },\r\n      deep: true\r\n    },\r\n    targets: {\r\n      handler() {\r\n        // 使用防抖处理，避免频繁重绘\r\n        if (this.renderTimer) {\r\n          clearTimeout(this.renderTimer);\r\n        }\r\n        this.renderTimer = setTimeout(() => {\r\n          this.drawOptimizedSimulation();\r\n        }, 50);\r\n      },\r\n      deep: true\r\n    },\r\n    // 添加对obstacles的监听，添加防御性检查\r\n    obstacles: {\r\n      handler(newObstacles) {\r\n        console.log('obstacles属性变化:', newObstacles);\r\n        \r\n        if (newObstacles === null || newObstacles === undefined) {\r\n          this.localObstacles = [];\r\n          console.warn('收到null/undefined障碍物数据');\r\n        } else if (Array.isArray(newObstacles)) {\r\n          this.localObstacles = [...newObstacles];\r\n          console.log(`更新本地障碍物数据(${this.localObstacles.length}个)`);\r\n        } else {\r\n          console.error('收到非数组障碍物数据:', newObstacles);\r\n          this.localObstacles = [];\r\n        }\r\n        \r\n        // 强制重绘以确保障碍物显示\r\n        this.drawSimulation(true);\r\n      },\r\n      deep: true,\r\n      immediate: true  // 确保组件挂载时立即触发\r\n    },\r\n    isRunning(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    isCaptured(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    showTrails(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    showVisionRange(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    showCommunicationRange(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    environmentSize() {\r\n      this.scale = this.canvasSize / this.environmentSize;\r\n      this.drawSimulation(true); // 强制完全重绘\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style scoped>\r\n.simulation-canvas {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  position: relative;\r\n  margin: 16px 0;\r\n}\r\n\r\n.simulation-canvas__area {\r\n  border: none;\r\n  border-radius: 8px;\r\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);\r\n  background-color: #fcfcff;\r\n}\r\n\r\n.capture-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background-color: rgba(255, 255, 255, 0.7);\r\n  border-radius: 8px;\r\n  animation: fadeIn 0.5s ease-in-out;\r\n}\r\n\r\n.capture-message {\r\n  background-color: rgba(255, 255, 255, 0.9);\r\n  padding: 16px 24px;\r\n  border-radius: 8px;\r\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 8px;\r\n  font-size: 1.5rem;\r\n  font-weight: bold;\r\n  color: #4caf50;\r\n  animation: pulse 2s infinite;\r\n}\r\n\r\n@keyframes fadeIn {\r\n  from { opacity: 0; }\r\n  to { opacity: 1; }\r\n}\r\n\r\n@keyframes pulse {\r\n  0% { transform: scale(1); }\r\n  50% { transform: scale(1.05); }\r\n  100% { transform: scale(1); }\r\n}\r\n</style>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}