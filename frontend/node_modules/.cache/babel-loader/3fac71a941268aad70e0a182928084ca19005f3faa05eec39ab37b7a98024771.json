{"ast":null,"code":"export default {\n  name: 'SimulationCanvas',\n  props: {\n    hunters: {\n      type: Array,\n      required: true\n    },\n    targets: {\n      type: Array,\n      required: true\n    },\n    environmentSize: {\n      type: Number,\n      default: 500\n    },\n    isRunning: {\n      type: Boolean,\n      default: false\n    },\n    isCaptured: {\n      type: Boolean,\n      default: false\n    },\n    showTrails: {\n      type: Boolean,\n      default: true\n    },\n    showVisionRange: {\n      type: Boolean,\n      default: false\n    },\n    showCommunicationRange: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data() {\n    return {\n      canvasSize: 600,\n      canvas: null,\n      ctx: null,\n      scale: 1,\n      colorMap: {\n        hunter: '#3f51b5',\n        // 蓝色\n        target: '#f44336',\n        // 红色\n        vision: 'rgba(63, 81, 181, 0.1)',\n        // 半透明蓝色\n        communication: 'rgba(63, 81, 181, 0.05)',\n        // 更透明的蓝色\n        trail: 'rgba(63, 81, 181, 0.5)',\n        // 半透明蓝色\n        captureRange: 'rgba(76, 175, 80, 0.3)',\n        // 半透明绿色\n        captured: 'rgba(244, 67, 54, 0.3)' // 半透明红色\n      },\n      // 新增：跟踪之前的位置，用于优化渲染\n      previousPositions: {\n        hunters: [],\n        targets: []\n      },\n      // 防抖渲染计时器\n      renderTimer: null,\n      // 帧率控制\n      lastRenderTime: 0,\n      targetFPS: 30,\n      // 渲染计数，用于降低非必要渲染的频率\n      renderCount: 0\n    };\n  },\n  mounted() {\n    this.initCanvas();\n    this.drawSimulation();\n\n    // 添加窗口大小变化监听\n    window.addEventListener('resize', this.handleResize);\n\n    // 使用requestAnimationFrame实现高效渲染循环\n    this.startRenderLoop();\n  },\n  beforeDestroy() {\n    // 清理事件监听器\n    window.removeEventListener('resize', this.handleResize);\n\n    // 停止渲染循环\n    this.stopRenderLoop();\n\n    // 清理计时器\n    if (this.renderTimer) {\n      clearTimeout(this.renderTimer);\n    }\n  },\n  methods: {\n    // 初始化画布\n    initCanvas() {\n      this.canvas = this.$refs.canvas;\n      this.ctx = this.canvas.getContext('2d');\n      this.scale = this.canvasSize / this.environmentSize;\n\n      // 初始化previousPositions\n      this.updatePreviousPositions();\n    },\n    // 处理窗口大小变化\n    handleResize() {\n      // 防抖处理\n      if (this.renderTimer) {\n        clearTimeout(this.renderTimer);\n      }\n      this.renderTimer = setTimeout(() => {\n        // 重新计算画布大小（可选，如果需要响应式调整画布大小）\n        // this.canvasSize = Math.min(window.innerWidth * 0.7, 600);\n        this.scale = this.canvasSize / this.environmentSize;\n        this.drawSimulation(true); // 强制完全重绘\n      }, 200);\n    },\n    // 启动渲染循环\n    startRenderLoop() {\n      if (!this.animationFrameId) {\n        this.lastRenderTime = performance.now();\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\n      }\n    },\n    // 停止渲染循环\n    stopRenderLoop() {\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n    },\n    // 渲染循环\n    renderLoop(timestamp) {\n      // 计算每帧的时间间隔\n      const elapsed = timestamp - this.lastRenderTime;\n      const frameTime = 1000 / this.targetFPS;\n\n      // 如果时间间隔足够，执行渲染\n      if (elapsed >= frameTime) {\n        this.lastRenderTime = timestamp;\n\n        // 检查位置是否有变化，有变化时才渲染\n        if (this.hasPositionsChanged() || this.isRunning) {\n          this.drawOptimizedSimulation();\n          this.updatePreviousPositions();\n        }\n      }\n\n      // 继续循环\n      this.animationFrameId = requestAnimationFrame(this.renderLoop);\n    },\n    // 检查位置是否有变化\n    hasPositionsChanged() {\n      // 优化：快速检查数组长度变化\n      if (this.hunters.length !== this.previousPositions.hunters.length || this.targets.length !== this.previousPositions.targets.length) {\n        return true;\n      }\n\n      // 检查运行状态变化\n      if (this.isRunning !== this.previousIsRunning || this.isCaptured !== this.previousIsCaptured) {\n        this.previousIsRunning = this.isRunning;\n        this.previousIsCaptured = this.isCaptured;\n        return true;\n      }\n\n      // 渲染计数，每5帧强制完全重绘一次（避免累积误差）\n      this.renderCount++;\n      if (this.renderCount >= 5) {\n        this.renderCount = 0;\n        return true;\n      }\n\n      // 只有在运行中或首次渲染时，才进行位置变化检查\n      if (!this.isRunning && this.previousPositions.hunters.length > 0) {\n        return false;\n      }\n\n      // 智能体位置变化检测\n      const threshold = 0.5; // 位置变化阈值\n\n      // 检查猎手位置变化\n      for (let i = 0; i < this.hunters.length; i++) {\n        const hunter = this.hunters[i];\n        const prevHunter = this.previousPositions.hunters[i];\n        if (!prevHunter) return true;\n        if (Math.abs(hunter.position[0] - prevHunter.position[0]) > threshold || Math.abs(hunter.position[1] - prevHunter.position[1]) > threshold) {\n          return true;\n        }\n      }\n\n      // 检查目标位置变化\n      for (let i = 0; i < this.targets.length; i++) {\n        const target = this.targets[i];\n        const prevTarget = this.previousPositions.targets[i];\n        if (!prevTarget) return true;\n        if (Math.abs(target.position[0] - prevTarget.position[0]) > threshold || Math.abs(target.position[1] - prevTarget.position[1]) > threshold) {\n          return true;\n        }\n      }\n      return false;\n    },\n    // 更新之前的位置\n    updatePreviousPositions() {\n      // 深拷贝位置数据\n      this.previousPositions.hunters = this.hunters.map(hunter => ({\n        id: hunter.id,\n        position: [...hunter.position]\n      }));\n      this.previousPositions.targets = this.targets.map(target => ({\n        id: target.id,\n        position: [...target.position]\n      }));\n    },\n    // 优化的绘制方法\n    drawOptimizedSimulation() {\n      if (!this.ctx) return;\n\n      // 清除画布\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\n\n      // 绘制环境边界\n      this.ctx.strokeStyle = '#ccc';\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\n\n      // 绘制捕获状态\n      if (this.isCaptured) {\n        this.ctx.fillStyle = this.colorMap.captured;\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.font = 'bold 32px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('目标已捕获!', this.canvasSize / 2, this.canvasSize / 2);\n      }\n\n      // 绘制轨迹（如果启用）\n      if (this.showTrails) {\n        this.drawTrails();\n      }\n\n      // 绘制视野和通信范围（如果启用）\n      if (this.showVisionRange || this.showCommunicationRange) {\n        this.drawRanges();\n      }\n\n      // 绘制猎手\n      this.hunters.forEach(hunter => {\n        this.drawAgent(hunter, 'hunter');\n      });\n\n      // 绘制目标\n      this.targets.forEach(target => {\n        this.drawAgent(target, 'target');\n      });\n    },\n    // 完整重绘方法\n    drawSimulation(forceFullRedraw = false) {\n      if (!this.ctx) return;\n\n      // 如果不需要强制重绘，使用优化版本\n      if (!forceFullRedraw && this.previousPositions.hunters.length > 0) {\n        return this.drawOptimizedSimulation();\n      }\n\n      // 清除画布\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\n\n      // 绘制环境边界\n      this.ctx.strokeStyle = '#ccc';\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\n\n      // 绘制捕获状态\n      if (this.isCaptured) {\n        this.ctx.fillStyle = this.colorMap.captured;\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.font = 'bold 32px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('目标已捕获!', this.canvasSize / 2, this.canvasSize / 2);\n      }\n\n      // 绘制轨迹（如果启用）\n      if (this.showTrails) {\n        this.drawTrails();\n      }\n\n      // 绘制视野和通信范围（如果启用）\n      if (this.showVisionRange || this.showCommunicationRange) {\n        this.drawRanges();\n      }\n\n      // 绘制猎手\n      this.hunters.forEach(hunter => {\n        this.drawAgent(hunter, 'hunter');\n      });\n\n      // 绘制目标\n      this.targets.forEach(target => {\n        this.drawAgent(target, 'target');\n      });\n\n      // 更新之前的位置\n      this.updatePreviousPositions();\n      this.previousIsRunning = this.isRunning;\n      this.previousIsCaptured = this.isCaptured;\n    },\n    // 单独绘制轨迹\n    drawTrails() {\n      // 绘制猎手轨迹\n      this.hunters.forEach(hunter => {\n        if (hunter.history && hunter.history.length > 1) {\n          this.ctx.beginPath();\n          const startPos = this.transformPosition(hunter.history[0]);\n          this.ctx.moveTo(startPos.x, startPos.y);\n          for (let i = 1; i < hunter.history.length; i++) {\n            const histPos = this.transformPosition(hunter.history[i]);\n            this.ctx.lineTo(histPos.x, histPos.y);\n          }\n          this.ctx.strokeStyle = this.colorMap.hunter;\n          this.ctx.lineWidth = 1;\n          this.ctx.stroke();\n        }\n      });\n\n      // 绘制目标轨迹\n      this.targets.forEach(target => {\n        if (target.history && target.history.length > 1) {\n          this.ctx.beginPath();\n          const startPos = this.transformPosition(target.history[0]);\n          this.ctx.moveTo(startPos.x, startPos.y);\n          for (let i = 1; i < target.history.length; i++) {\n            const histPos = this.transformPosition(target.history[i]);\n            this.ctx.lineTo(histPos.x, histPos.y);\n          }\n          this.ctx.strokeStyle = this.colorMap.target;\n          this.ctx.lineWidth = 1;\n          this.ctx.stroke();\n        }\n      });\n    },\n    // 单独绘制视野和通信范围\n    drawRanges() {\n      // 绘制猎手视野和通信范围\n      this.hunters.forEach(hunter => {\n        const pos = this.transformPosition(hunter.position);\n\n        // 绘制视野范围\n        if (this.showVisionRange) {\n          this.ctx.beginPath();\n          this.ctx.arc(pos.x, pos.y, hunter.vision_range * this.scale, 0, Math.PI * 2);\n          this.ctx.fillStyle = this.colorMap.vision;\n          this.ctx.fill();\n        }\n\n        // 绘制通信范围\n        if (this.showCommunicationRange) {\n          this.ctx.beginPath();\n          this.ctx.arc(pos.x, pos.y, hunter.communication_range * this.scale, 0, Math.PI * 2);\n          this.ctx.fillStyle = this.colorMap.communication;\n          this.ctx.fill();\n        }\n\n        // 绘制捕获范围\n        this.ctx.beginPath();\n        this.ctx.arc(pos.x, pos.y, 10 * this.scale, 0, Math.PI * 2); // 捕获范围固定为10\n        this.ctx.fillStyle = this.colorMap.captureRange;\n        this.ctx.fill();\n      });\n\n      // 绘制目标视野范围\n      this.targets.forEach(target => {\n        if (this.showVisionRange) {\n          const pos = this.transformPosition(target.position);\n          this.ctx.beginPath();\n          this.ctx.arc(pos.x, pos.y, target.vision_range * this.scale, 0, Math.PI * 2);\n          this.ctx.fillStyle = 'rgba(244, 67, 54, 0.1)'; // 半透明红色\n          this.ctx.fill();\n        }\n      });\n    },\n    // 绘制智能体\n    drawAgent(agent, type) {\n      const pos = this.transformPosition(agent.position);\n\n      // 绘制智能体\n      this.ctx.beginPath();\n      this.ctx.arc(pos.x, pos.y, type === 'hunter' ? 5 : 8, 0, Math.PI * 2);\n      this.ctx.fillStyle = this.colorMap[type];\n      this.ctx.fill();\n      this.ctx.strokeStyle = '#fff';\n      this.ctx.lineWidth = 1;\n      this.ctx.stroke();\n\n      // 绘制ID标签\n      this.ctx.font = '10px Arial';\n      this.ctx.fillStyle = '#000';\n      this.ctx.textAlign = 'center';\n      this.ctx.fillText(agent.id.toString(), pos.x, pos.y + (type === 'hunter' ? 15 : 20));\n    },\n    // 转换坐标\n    transformPosition(position) {\n      // 将模拟坐标转换为画布坐标\n      return {\n        x: position[0] * this.scale,\n        y: position[1] * this.scale\n      };\n    },\n    // 清除特定区域\n    clearAgentArea(position, radius = 20) {\n      const pos = this.transformPosition(position);\n      this.ctx.clearRect(pos.x - radius, pos.y - radius, radius * 2, radius * 2);\n    }\n  },\n  watch: {\n    hunters: {\n      handler() {\n        // 使用防抖处理，避免频繁重绘\n        if (this.renderTimer) {\n          clearTimeout(this.renderTimer);\n        }\n        this.renderTimer = setTimeout(() => {\n          this.drawOptimizedSimulation();\n        }, 50);\n      },\n      deep: true\n    },\n    targets: {\n      handler() {\n        // 使用防抖处理，避免频繁重绘\n        if (this.renderTimer) {\n          clearTimeout(this.renderTimer);\n        }\n        this.renderTimer = setTimeout(() => {\n          this.drawOptimizedSimulation();\n        }, 50);\n      },\n      deep: true\n    },\n    isRunning(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    isCaptured(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    showTrails(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    showVisionRange(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    showCommunicationRange(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    environmentSize() {\n      this.scale = this.canvasSize / this.environmentSize;\n      this.drawSimulation(true); // 强制完全重绘\n    }\n  }\n};","map":{"version":3,"names":["name","props","hunters","type","Array","required","targets","environmentSize","Number","default","isRunning","Boolean","isCaptured","showTrails","showVisionRange","showCommunicationRange","data","canvasSize","canvas","ctx","scale","colorMap","hunter","target","vision","communication","trail","captureRange","captured","previousPositions","renderTimer","lastRenderTime","targetFPS","renderCount","mounted","initCanvas","drawSimulation","window","addEventListener","handleResize","startRenderLoop","beforeDestroy","removeEventListener","stopRenderLoop","clearTimeout","methods","$refs","getContext","updatePreviousPositions","setTimeout","animationFrameId","performance","now","requestAnimationFrame","renderLoop","cancelAnimationFrame","timestamp","elapsed","frameTime","hasPositionsChanged","drawOptimizedSimulation","length","previousIsRunning","previousIsCaptured","threshold","i","prevHunter","Math","abs","position","prevTarget","map","id","clearRect","strokeStyle","lineWidth","strokeRect","fillStyle","fillRect","font","textAlign","fillText","drawTrails","drawRanges","forEach","drawAgent","forceFullRedraw","history","beginPath","startPos","transformPosition","moveTo","x","y","histPos","lineTo","stroke","pos","arc","vision_range","PI","fill","communication_range","agent","toString","clearAgentArea","radius","watch","handler","deep","newVal","oldVal"],"sources":["src/components/SimulationCanvas.vue"],"sourcesContent":["<template>\r\n    <div class=\"simulation-canvas\">\r\n      <canvas \r\n        ref=\"canvas\" \r\n        :width=\"canvasSize\" \r\n        :height=\"canvasSize\" \r\n        class=\"simulation-canvas__area\"\r\n      ></canvas>\r\n      <div class=\"simulation-canvas__controls\">\r\n        <v-btn \r\n          color=\"primary\" \r\n          :disabled=\"isRunning || isCaptured\" \r\n          @click=\"$emit('start')\"\r\n        >\r\n          <v-icon left>mdi-play</v-icon> 开始\r\n        </v-btn>\r\n        <v-btn \r\n          color=\"error\" \r\n          :disabled=\"!isRunning\" \r\n          @click=\"$emit('stop')\"\r\n        >\r\n          <v-icon left>mdi-stop</v-icon> 停止\r\n        </v-btn>\r\n        <v-btn \r\n          color=\"warning\" \r\n          :disabled=\"isRunning\" \r\n          @click=\"$emit('reset')\"\r\n        >\r\n          <v-icon left>mdi-refresh</v-icon> 重置\r\n        </v-btn>\r\n      </div>\r\n    </div>\r\n  </template>\r\n  \r\n  <script>\r\n  export default {\r\n    name: 'SimulationCanvas',\r\n    props: {\r\n      hunters: {\r\n        type: Array,\r\n        required: true\r\n      },\r\n      targets: {\r\n        type: Array,\r\n        required: true\r\n      },\r\n      environmentSize: {\r\n        type: Number,\r\n        default: 500\r\n      },\r\n      isRunning: {\r\n        type: Boolean,\r\n        default: false\r\n      },\r\n      isCaptured: {\r\n        type: Boolean,\r\n        default: false\r\n      },\r\n      showTrails: {\r\n        type: Boolean,\r\n        default: true\r\n      },\r\n      showVisionRange: {\r\n        type: Boolean,\r\n        default: false\r\n      },\r\n      showCommunicationRange: {\r\n        type: Boolean,\r\n        default: false\r\n      }\r\n    },\r\n    data() {\r\n      return {\r\n        canvasSize: 600,\r\n        canvas: null,\r\n        ctx: null,\r\n        scale: 1,\r\n        colorMap: {\r\n          hunter: '#3f51b5', // 蓝色\r\n          target: '#f44336', // 红色\r\n          vision: 'rgba(63, 81, 181, 0.1)', // 半透明蓝色\r\n          communication: 'rgba(63, 81, 181, 0.05)', // 更透明的蓝色\r\n          trail: 'rgba(63, 81, 181, 0.5)', // 半透明蓝色\r\n          captureRange: 'rgba(76, 175, 80, 0.3)', // 半透明绿色\r\n          captured: 'rgba(244, 67, 54, 0.3)' // 半透明红色\r\n        },\r\n        // 新增：跟踪之前的位置，用于优化渲染\r\n        previousPositions: {\r\n          hunters: [],\r\n          targets: []\r\n        },\r\n        // 防抖渲染计时器\r\n        renderTimer: null,\r\n        // 帧率控制\r\n        lastRenderTime: 0,\r\n        targetFPS: 30,\r\n        // 渲染计数，用于降低非必要渲染的频率\r\n        renderCount: 0\r\n      }\r\n    },\r\n    mounted() {\r\n      this.initCanvas();\r\n      this.drawSimulation();\r\n      \r\n      // 添加窗口大小变化监听\r\n      window.addEventListener('resize', this.handleResize);\r\n      \r\n      // 使用requestAnimationFrame实现高效渲染循环\r\n      this.startRenderLoop();\r\n    },\r\n    beforeDestroy() {\r\n      // 清理事件监听器\r\n      window.removeEventListener('resize', this.handleResize);\r\n      \r\n      // 停止渲染循环\r\n      this.stopRenderLoop();\r\n      \r\n      // 清理计时器\r\n      if (this.renderTimer) {\r\n        clearTimeout(this.renderTimer);\r\n      }\r\n    },\r\n    methods: {\r\n      // 初始化画布\r\n      initCanvas() {\r\n        this.canvas = this.$refs.canvas;\r\n        this.ctx = this.canvas.getContext('2d');\r\n        this.scale = this.canvasSize / this.environmentSize;\r\n        \r\n        // 初始化previousPositions\r\n        this.updatePreviousPositions();\r\n      },\r\n      \r\n      // 处理窗口大小变化\r\n      handleResize() {\r\n        // 防抖处理\r\n        if (this.renderTimer) {\r\n          clearTimeout(this.renderTimer);\r\n        }\r\n        \r\n        this.renderTimer = setTimeout(() => {\r\n          // 重新计算画布大小（可选，如果需要响应式调整画布大小）\r\n          // this.canvasSize = Math.min(window.innerWidth * 0.7, 600);\r\n          this.scale = this.canvasSize / this.environmentSize;\r\n          this.drawSimulation(true); // 强制完全重绘\r\n        }, 200);\r\n      },\r\n      \r\n      // 启动渲染循环\r\n      startRenderLoop() {\r\n        if (!this.animationFrameId) {\r\n          this.lastRenderTime = performance.now();\r\n          this.animationFrameId = requestAnimationFrame(this.renderLoop);\r\n        }\r\n      },\r\n      \r\n      // 停止渲染循环\r\n      stopRenderLoop() {\r\n        if (this.animationFrameId) {\r\n          cancelAnimationFrame(this.animationFrameId);\r\n          this.animationFrameId = null;\r\n        }\r\n      },\r\n      \r\n      // 渲染循环\r\n      renderLoop(timestamp) {\r\n        // 计算每帧的时间间隔\r\n        const elapsed = timestamp - this.lastRenderTime;\r\n        const frameTime = 1000 / this.targetFPS;\r\n        \r\n        // 如果时间间隔足够，执行渲染\r\n        if (elapsed >= frameTime) {\r\n          this.lastRenderTime = timestamp;\r\n          \r\n          // 检查位置是否有变化，有变化时才渲染\r\n          if (this.hasPositionsChanged() || this.isRunning) {\r\n            this.drawOptimizedSimulation();\r\n            this.updatePreviousPositions();\r\n          }\r\n        }\r\n        \r\n        // 继续循环\r\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\r\n      },\r\n      \r\n      // 检查位置是否有变化\r\n      hasPositionsChanged() {\r\n        // 优化：快速检查数组长度变化\r\n        if (this.hunters.length !== this.previousPositions.hunters.length ||\r\n            this.targets.length !== this.previousPositions.targets.length) {\r\n          return true;\r\n        }\r\n        \r\n        // 检查运行状态变化\r\n        if (this.isRunning !== this.previousIsRunning ||\r\n            this.isCaptured !== this.previousIsCaptured) {\r\n          this.previousIsRunning = this.isRunning;\r\n          this.previousIsCaptured = this.isCaptured;\r\n          return true;\r\n        }\r\n        \r\n        // 渲染计数，每5帧强制完全重绘一次（避免累积误差）\r\n        this.renderCount++;\r\n        if (this.renderCount >= 5) {\r\n          this.renderCount = 0;\r\n          return true;\r\n        }\r\n        \r\n        // 只有在运行中或首次渲染时，才进行位置变化检查\r\n        if (!this.isRunning && this.previousPositions.hunters.length > 0) {\r\n          return false;\r\n        }\r\n        \r\n        // 智能体位置变化检测\r\n        const threshold = 0.5; // 位置变化阈值\r\n        \r\n        // 检查猎手位置变化\r\n        for (let i = 0; i < this.hunters.length; i++) {\r\n          const hunter = this.hunters[i];\r\n          const prevHunter = this.previousPositions.hunters[i];\r\n          \r\n          if (!prevHunter) return true;\r\n          \r\n          if (Math.abs(hunter.position[0] - prevHunter.position[0]) > threshold ||\r\n              Math.abs(hunter.position[1] - prevHunter.position[1]) > threshold) {\r\n            return true;\r\n          }\r\n        }\r\n        \r\n        // 检查目标位置变化\r\n        for (let i = 0; i < this.targets.length; i++) {\r\n          const target = this.targets[i];\r\n          const prevTarget = this.previousPositions.targets[i];\r\n          \r\n          if (!prevTarget) return true;\r\n          \r\n          if (Math.abs(target.position[0] - prevTarget.position[0]) > threshold ||\r\n              Math.abs(target.position[1] - prevTarget.position[1]) > threshold) {\r\n            return true;\r\n          }\r\n        }\r\n        \r\n        return false;\r\n      },\r\n      \r\n      // 更新之前的位置\r\n      updatePreviousPositions() {\r\n        // 深拷贝位置数据\r\n        this.previousPositions.hunters = this.hunters.map(hunter => ({\r\n          id: hunter.id,\r\n          position: [...hunter.position]\r\n        }));\r\n        \r\n        this.previousPositions.targets = this.targets.map(target => ({\r\n          id: target.id,\r\n          position: [...target.position]\r\n        }));\r\n      },\r\n      \r\n      // 优化的绘制方法\r\n      drawOptimizedSimulation() {\r\n        if (!this.ctx) return;\r\n        \r\n        // 清除画布\r\n        this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\r\n        \r\n        // 绘制环境边界\r\n        this.ctx.strokeStyle = '#ccc';\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\r\n        \r\n        // 绘制捕获状态\r\n        if (this.isCaptured) {\r\n          this.ctx.fillStyle = this.colorMap.captured;\r\n          this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n          this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n          this.ctx.font = 'bold 32px Arial';\r\n          this.ctx.textAlign = 'center';\r\n          this.ctx.fillText('目标已捕获!', this.canvasSize / 2, this.canvasSize / 2);\r\n        }\r\n        \r\n        // 绘制轨迹（如果启用）\r\n        if (this.showTrails) {\r\n          this.drawTrails();\r\n        }\r\n        \r\n        // 绘制视野和通信范围（如果启用）\r\n        if (this.showVisionRange || this.showCommunicationRange) {\r\n          this.drawRanges();\r\n        }\r\n        \r\n        // 绘制猎手\r\n        this.hunters.forEach(hunter => {\r\n          this.drawAgent(hunter, 'hunter');\r\n        });\r\n        \r\n        // 绘制目标\r\n        this.targets.forEach(target => {\r\n          this.drawAgent(target, 'target');\r\n        });\r\n      },\r\n      \r\n      // 完整重绘方法\r\n      drawSimulation(forceFullRedraw = false) {\r\n        if (!this.ctx) return;\r\n        \r\n        // 如果不需要强制重绘，使用优化版本\r\n        if (!forceFullRedraw && this.previousPositions.hunters.length > 0) {\r\n          return this.drawOptimizedSimulation();\r\n        }\r\n        \r\n        // 清除画布\r\n        this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\r\n        \r\n        // 绘制环境边界\r\n        this.ctx.strokeStyle = '#ccc';\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\r\n        \r\n        // 绘制捕获状态\r\n        if (this.isCaptured) {\r\n          this.ctx.fillStyle = this.colorMap.captured;\r\n          this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n          this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n          this.ctx.font = 'bold 32px Arial';\r\n          this.ctx.textAlign = 'center';\r\n          this.ctx.fillText('目标已捕获!', this.canvasSize / 2, this.canvasSize / 2);\r\n        }\r\n        \r\n        // 绘制轨迹（如果启用）\r\n        if (this.showTrails) {\r\n          this.drawTrails();\r\n        }\r\n        \r\n        // 绘制视野和通信范围（如果启用）\r\n        if (this.showVisionRange || this.showCommunicationRange) {\r\n          this.drawRanges();\r\n        }\r\n        \r\n        // 绘制猎手\r\n        this.hunters.forEach(hunter => {\r\n          this.drawAgent(hunter, 'hunter');\r\n        });\r\n        \r\n        // 绘制目标\r\n        this.targets.forEach(target => {\r\n          this.drawAgent(target, 'target');\r\n        });\r\n        \r\n        // 更新之前的位置\r\n        this.updatePreviousPositions();\r\n        this.previousIsRunning = this.isRunning;\r\n        this.previousIsCaptured = this.isCaptured;\r\n      },\r\n      \r\n      // 单独绘制轨迹\r\n      drawTrails() {\r\n        // 绘制猎手轨迹\r\n        this.hunters.forEach(hunter => {\r\n          if (hunter.history && hunter.history.length > 1) {\r\n            this.ctx.beginPath();\r\n            const startPos = this.transformPosition(hunter.history[0]);\r\n            this.ctx.moveTo(startPos.x, startPos.y);\r\n            \r\n            for (let i = 1; i < hunter.history.length; i++) {\r\n              const histPos = this.transformPosition(hunter.history[i]);\r\n              this.ctx.lineTo(histPos.x, histPos.y);\r\n            }\r\n            \r\n            this.ctx.strokeStyle = this.colorMap.hunter;\r\n            this.ctx.lineWidth = 1;\r\n            this.ctx.stroke();\r\n          }\r\n        });\r\n        \r\n        // 绘制目标轨迹\r\n        this.targets.forEach(target => {\r\n          if (target.history && target.history.length > 1) {\r\n            this.ctx.beginPath();\r\n            const startPos = this.transformPosition(target.history[0]);\r\n            this.ctx.moveTo(startPos.x, startPos.y);\r\n            \r\n            for (let i = 1; i < target.history.length; i++) {\r\n              const histPos = this.transformPosition(target.history[i]);\r\n              this.ctx.lineTo(histPos.x, histPos.y);\r\n            }\r\n            \r\n            this.ctx.strokeStyle = this.colorMap.target;\r\n            this.ctx.lineWidth = 1;\r\n            this.ctx.stroke();\r\n          }\r\n        });\r\n      },\r\n      \r\n      // 单独绘制视野和通信范围\r\n      drawRanges() {\r\n        // 绘制猎手视野和通信范围\r\n        this.hunters.forEach(hunter => {\r\n          const pos = this.transformPosition(hunter.position);\r\n          \r\n          // 绘制视野范围\r\n          if (this.showVisionRange) {\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(pos.x, pos.y, hunter.vision_range * this.scale, 0, Math.PI * 2);\r\n            this.ctx.fillStyle = this.colorMap.vision;\r\n            this.ctx.fill();\r\n          }\r\n          \r\n          // 绘制通信范围\r\n          if (this.showCommunicationRange) {\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(pos.x, pos.y, hunter.communication_range * this.scale, 0, Math.PI * 2);\r\n            this.ctx.fillStyle = this.colorMap.communication;\r\n            this.ctx.fill();\r\n          }\r\n          \r\n          // 绘制捕获范围\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, 10 * this.scale, 0, Math.PI * 2); // 捕获范围固定为10\r\n          this.ctx.fillStyle = this.colorMap.captureRange;\r\n          this.ctx.fill();\r\n        });\r\n        \r\n        // 绘制目标视野范围\r\n        this.targets.forEach(target => {\r\n          if (this.showVisionRange) {\r\n            const pos = this.transformPosition(target.position);\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(pos.x, pos.y, target.vision_range * this.scale, 0, Math.PI * 2);\r\n            this.ctx.fillStyle = 'rgba(244, 67, 54, 0.1)'; // 半透明红色\r\n            this.ctx.fill();\r\n          }\r\n        });\r\n      },\r\n      \r\n      // 绘制智能体\r\n      drawAgent(agent, type) {\r\n        const pos = this.transformPosition(agent.position);\r\n        \r\n        // 绘制智能体\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(pos.x, pos.y, type === 'hunter' ? 5 : 8, 0, Math.PI * 2);\r\n        this.ctx.fillStyle = this.colorMap[type];\r\n        this.ctx.fill();\r\n        this.ctx.strokeStyle = '#fff';\r\n        this.ctx.lineWidth = 1;\r\n        this.ctx.stroke();\r\n        \r\n        // 绘制ID标签\r\n        this.ctx.font = '10px Arial';\r\n        this.ctx.fillStyle = '#000';\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.fillText(agent.id.toString(), pos.x, pos.y + (type === 'hunter' ? 15 : 20));\r\n      },\r\n      \r\n      // 转换坐标\r\n      transformPosition(position) {\r\n        // 将模拟坐标转换为画布坐标\r\n        return {\r\n          x: position[0] * this.scale,\r\n          y: position[1] * this.scale\r\n        }\r\n      },\r\n      \r\n      // 清除特定区域\r\n      clearAgentArea(position, radius = 20) {\r\n        const pos = this.transformPosition(position);\r\n        this.ctx.clearRect(pos.x - radius, pos.y - radius, radius * 2, radius * 2);\r\n      }\r\n    },\r\n    watch: {\r\n      hunters: {\r\n        handler() {\r\n          // 使用防抖处理，避免频繁重绘\r\n          if (this.renderTimer) {\r\n            clearTimeout(this.renderTimer);\r\n          }\r\n          this.renderTimer = setTimeout(() => {\r\n            this.drawOptimizedSimulation();\r\n          }, 50);\r\n        },\r\n        deep: true\r\n      },\r\n      targets: {\r\n        handler() {\r\n          // 使用防抖处理，避免频繁重绘\r\n          if (this.renderTimer) {\r\n            clearTimeout(this.renderTimer);\r\n          }\r\n          this.renderTimer = setTimeout(() => {\r\n            this.drawOptimizedSimulation();\r\n          }, 50);\r\n        },\r\n        deep: true\r\n      },\r\n      isRunning(newVal, oldVal) {\r\n        if (newVal !== oldVal) {\r\n          this.drawSimulation();\r\n        }\r\n      },\r\n      isCaptured(newVal, oldVal) {\r\n        if (newVal !== oldVal) {\r\n          this.drawSimulation();\r\n        }\r\n      },\r\n      showTrails(newVal, oldVal) {\r\n        if (newVal !== oldVal) {\r\n          this.drawSimulation();\r\n        }\r\n      },\r\n      showVisionRange(newVal, oldVal) {\r\n        if (newVal !== oldVal) {\r\n          this.drawSimulation();\r\n        }\r\n      },\r\n      showCommunicationRange(newVal, oldVal) {\r\n        if (newVal !== oldVal) {\r\n          this.drawSimulation();\r\n        }\r\n      },\r\n      environmentSize() {\r\n        this.scale = this.canvasSize / this.environmentSize;\r\n        this.drawSimulation(true); // 强制完全重绘\r\n      }\r\n    }\r\n  }\r\n  </script>\r\n  \r\n  <style scoped>\r\n  .simulation-canvas {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    margin-bottom: 20px;\r\n  }\r\n  \r\n  .simulation-canvas__area {\r\n    border: 1px solid #ccc;\r\n    border-radius: 4px;\r\n    background-color: #f9f9f9;\r\n    margin-bottom: 16px;\r\n  }\r\n  \r\n  .simulation-canvas__controls {\r\n    display: flex;\r\n    gap: 16px;\r\n  }\r\n  </style>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}