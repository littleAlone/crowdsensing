{"ast":null,"code":"import _createForOfIteratorHelper from \"F:/python/course/crowdsensing/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"F:/python/course/crowdsensing/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\nexport default {\n  name: 'SimulationCanvas',\n  props: {\n    hunters: {\n      type: Array,\n      required: true\n    },\n    targets: {\n      type: Array,\n      required: true\n    },\n    environmentSize: {\n      type: Number,\n      \"default\": 500\n    },\n    isRunning: {\n      type: Boolean,\n      \"default\": false\n    },\n    isCaptured: {\n      type: Boolean,\n      \"default\": false\n    },\n    showTrails: {\n      type: Boolean,\n      \"default\": true\n    },\n    showVisionRange: {\n      type: Boolean,\n      \"default\": false\n    },\n    showCommunicationRange: {\n      type: Boolean,\n      \"default\": false\n    },\n    // 新增:障碍物属性\n    obstacles: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    }\n  },\n  data: function data() {\n    return {\n      canvasSize: 600,\n      canvas: null,\n      ctx: null,\n      scale: 1,\n      colorMap: {\n        hunter: '#3f51b5',\n        // 蓝色\n        target: '#f44336',\n        // 红色\n        vision: 'rgba(63, 81, 181, 0.1)',\n        // 半透明蓝色\n        communication: 'rgba(63, 81, 181, 0.05)',\n        // 更透明的蓝色\n        trail: 'rgba(63, 81, 181, 0.5)',\n        // 半透明蓝色\n        captureRange: 'rgba(76, 175, 80, 0.3)',\n        // 半透明绿色\n        captured: 'rgba(244, 67, 54, 0.3)',\n        // 半透明红色\n        obstacle: 'rgba(95, 95, 95, 0.7)' // 障碍物颜色\n      },\n      // 角色样式映射\n      roleStyles: {\n        tracker: {\n          color: '#4285F4',\n          size: 6\n        },\n        // 追踪者\n        interceptor: {\n          color: '#EA4335',\n          size: 6\n        },\n        // 拦截者\n        coordinator: {\n          color: '#FBBC05',\n          size: 7\n        },\n        // 协调者\n        flanker: {\n          color: '#34A853',\n          size: 6\n        },\n        // 侧翼者\n        standard: {\n          color: '#3f51b5',\n          size: 5\n        } // 默认\n      },\n      // 新增：跟踪之前的位置，用于优化渲染\n      previousPositions: {\n        hunters: [],\n        targets: []\n      },\n      // 防抖渲染计时器\n      renderTimer: null,\n      // 帧率控制\n      lastRenderTime: 0,\n      targetFPS: 30,\n      // 渲染计数，用于降低非必要渲染的频率\n      renderCount: 0\n    };\n  },\n  mounted: function mounted() {\n    this.initCanvas();\n    this.drawSimulation();\n\n    // 添加窗口大小变化监听\n    window.addEventListener('resize', this.handleResize);\n\n    // 使用requestAnimationFrame实现高效渲染循环\n    this.startRenderLoop();\n  },\n  beforeDestroy: function beforeDestroy() {\n    // 清理事件监听器\n    window.removeEventListener('resize', this.handleResize);\n\n    // 停止渲染循环\n    this.stopRenderLoop();\n\n    // 清理计时器\n    if (this.renderTimer) {\n      clearTimeout(this.renderTimer);\n    }\n  },\n  methods: {\n    // 初始化画布\n    initCanvas: function initCanvas() {\n      this.canvas = this.$refs.canvas;\n      this.ctx = this.canvas.getContext('2d');\n      this.scale = this.canvasSize / this.environmentSize;\n\n      // 初始化previousPositions\n      this.updatePreviousPositions();\n    },\n    // 处理窗口大小变化\n    handleResize: function handleResize() {\n      var _this = this;\n      // 防抖处理\n      if (this.renderTimer) {\n        clearTimeout(this.renderTimer);\n      }\n      this.renderTimer = setTimeout(function () {\n        // 重新计算画布大小（可选，如果需要响应式调整画布大小）\n        // this.canvasSize = Math.min(window.innerWidth * 0.7, 600);\n        _this.scale = _this.canvasSize / _this.environmentSize;\n        _this.drawSimulation(true); // 强制完全重绘\n      }, 200);\n    },\n    // 启动渲染循环\n    startRenderLoop: function startRenderLoop() {\n      if (!this.animationFrameId) {\n        this.lastRenderTime = performance.now();\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\n      }\n    },\n    // 停止渲染循环\n    stopRenderLoop: function stopRenderLoop() {\n      if (this.animationFrameId) {\n        cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = null;\n      }\n    },\n    // 渲染循环\n    renderLoop: function renderLoop(timestamp) {\n      // 计算每帧的时间间隔\n      var elapsed = timestamp - this.lastRenderTime;\n      var frameTime = 1000 / this.targetFPS;\n\n      // 如果时间间隔足够，执行渲染\n      if (elapsed >= frameTime) {\n        this.lastRenderTime = timestamp;\n\n        // 检查位置是否有变化，有变化时才渲染\n        if (this.hasPositionsChanged() || this.isRunning) {\n          this.drawOptimizedSimulation();\n          this.updatePreviousPositions();\n        }\n      }\n\n      // 继续循环\n      this.animationFrameId = requestAnimationFrame(this.renderLoop);\n    },\n    // 检查位置是否有变化\n    hasPositionsChanged: function hasPositionsChanged() {\n      // 优化：快速检查数组长度变化\n      if (this.hunters.length !== this.previousPositions.hunters.length || this.targets.length !== this.previousPositions.targets.length) {\n        return true;\n      }\n\n      // 检查运行状态变化\n      if (this.isRunning !== this.previousIsRunning || this.isCaptured !== this.previousIsCaptured) {\n        this.previousIsRunning = this.isRunning;\n        this.previousIsCaptured = this.isCaptured;\n        return true;\n      }\n\n      // 渲染计数，每5帧强制完全重绘一次（避免累积误差）\n      this.renderCount++;\n      if (this.renderCount >= 5) {\n        this.renderCount = 0;\n        return true;\n      }\n\n      // 只有在运行中或首次渲染时，才进行位置变化检查\n      if (!this.isRunning && this.previousPositions.hunters.length > 0) {\n        return false;\n      }\n\n      // 智能体位置变化检测\n      var threshold = 0.5; // 位置变化阈值\n\n      // 检查猎手位置变化\n      for (var i = 0; i < this.hunters.length; i++) {\n        var hunter = this.hunters[i];\n        var prevHunter = this.previousPositions.hunters[i];\n        if (!prevHunter) return true;\n        if (Math.abs(hunter.position[0] - prevHunter.position[0]) > threshold || Math.abs(hunter.position[1] - prevHunter.position[1]) > threshold) {\n          return true;\n        }\n      }\n\n      // 检查目标位置变化\n      for (var _i = 0; _i < this.targets.length; _i++) {\n        var target = this.targets[_i];\n        var prevTarget = this.previousPositions.targets[_i];\n        if (!prevTarget) return true;\n        if (Math.abs(target.position[0] - prevTarget.position[0]) > threshold || Math.abs(target.position[1] - prevTarget.position[1]) > threshold) {\n          return true;\n        }\n      }\n      return false;\n    },\n    // 更新之前的位置\n    updatePreviousPositions: function updatePreviousPositions() {\n      // 深拷贝位置数据\n      this.previousPositions.hunters = this.hunters.map(function (hunter) {\n        return {\n          id: hunter.id,\n          position: _toConsumableArray(hunter.position)\n        };\n      });\n      this.previousPositions.targets = this.targets.map(function (target) {\n        return {\n          id: target.id,\n          position: _toConsumableArray(target.position)\n        };\n      });\n    },\n    // 优化的绘制方法\n    drawOptimizedSimulation: function drawOptimizedSimulation() {\n      var _this2 = this;\n      if (!this.ctx) return;\n\n      // 清除画布\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\n      this.drawBackground();\n\n      // 绘制环境边界\n      this.ctx.strokeStyle = '#ccc';\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\n\n      // 绘制障碍物\n      this.drawObstacles();\n\n      // 绘制捕获状态\n      if (this.isCaptured) {\n        this.ctx.fillStyle = this.colorMap.captured;\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.font = 'bold 32px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('目标已捕获!', this.canvasSize / 2, this.canvasSize / 2);\n      }\n\n      // 绘制轨迹（如果启用）\n      if (this.showTrails) {\n        this.drawTrails();\n      }\n\n      // 绘制视野和通信范围（如果启用）\n      if (this.showVisionRange || this.showCommunicationRange) {\n        this.drawRanges();\n      }\n\n      // 绘制猎手\n      this.hunters.forEach(function (hunter) {\n        _this2.drawHunter(hunter);\n      });\n\n      // 绘制目标\n      this.targets.forEach(function (target) {\n        _this2.drawAgent(target, 'target');\n      });\n    },\n    // 绘制障碍物\n    drawObstacles: function drawObstacles() {\n      if (!this.obstacles || !this.obstacles.length) return;\n      var _iterator = _createForOfIteratorHelper(this.obstacles),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var obstacle = _step.value;\n          var pos = this.transformPosition(obstacle.position);\n          var radius = obstacle.radius * this.scale;\n\n          // 创建渐变效果\n          var gradient = this.ctx.createRadialGradient(pos.x, pos.y, radius * 0.2, pos.x, pos.y, radius);\n          gradient.addColorStop(0, 'rgba(90, 90, 100, 0.9)');\n          gradient.addColorStop(0.7, 'rgba(70, 70, 85, 0.85)');\n          gradient.addColorStop(1, 'rgba(50, 50, 65, 0.8)');\n\n          // 绘制主体\n          this.ctx.beginPath();\n          this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\n          this.ctx.fillStyle = gradient;\n          this.ctx.fill();\n\n          // 添加边缘光晕效果\n          this.ctx.strokeStyle = 'rgba(120, 120, 140, 0.5)';\n          this.ctx.lineWidth = 2;\n          this.ctx.stroke();\n\n          // 添加内部纹理\n          this.drawObstacleTexture(pos.x, pos.y, radius);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    },\n    drawObstacleTexture: function drawObstacleTexture(x, y, radius) {\n      // 随机生成内部小圆点\n      var dotsCount = Math.floor(radius / 4);\n      this.ctx.fillStyle = 'rgba(40, 40, 55, 0.5)';\n      for (var i = 0; i < dotsCount; i++) {\n        var angle = Math.random() * Math.PI * 2;\n        var distance = Math.random() * radius * 0.8;\n        var dotX = x + Math.cos(angle) * distance;\n        var dotY = y + Math.sin(angle) * distance;\n        var dotSize = Math.random() * 3 + 1;\n        this.ctx.beginPath();\n        this.ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);\n        this.ctx.fill();\n      }\n    },\n    drawBackground: function drawBackground() {\n      var gridSize = 25 * this.scale;\n      var width = this.canvasSize;\n      var height = this.canvasSize;\n      this.ctx.strokeStyle = 'rgba(200, 200, 220, 0.2)';\n      this.ctx.lineWidth = 1;\n\n      // 绘制网格线\n      for (var x = 0; x <= width; x += gridSize) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(x, 0);\n        this.ctx.lineTo(x, height);\n        this.ctx.stroke();\n      }\n      for (var y = 0; y <= height; y += gridSize) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(0, y);\n        this.ctx.lineTo(width, y);\n        this.ctx.stroke();\n      }\n\n      // 添加坐标轴\n      this.ctx.strokeStyle = 'rgba(150, 150, 180, 0.4)';\n      this.ctx.lineWidth = 2;\n\n      // x轴\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, height / 2);\n      this.ctx.lineTo(width, height / 2);\n      this.ctx.stroke();\n\n      // y轴\n      this.ctx.beginPath();\n      this.ctx.moveTo(width / 2, 0);\n      this.ctx.lineTo(width / 2, height);\n      this.ctx.stroke();\n    },\n    // 完整重绘方法\n    drawSimulation: function drawSimulation() {\n      var _this3 = this;\n      var forceFullRedraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (!this.ctx) return;\n\n      // 如果不需要强制重绘，使用优化版本\n      if (!forceFullRedraw && this.previousPositions.hunters.length > 0) {\n        return this.drawOptimizedSimulation();\n      }\n\n      // 清除画布\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\n      this.drawBackground();\n\n      // 绘制环境边界\n      this.ctx.strokeStyle = '#ccc';\n      this.ctx.lineWidth = 2;\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\n\n      // 绘制障碍物\n      this.drawObstacles();\n\n      // 绘制捕获状态\n      if (this.isCaptured) {\n        this.ctx.fillStyle = this.colorMap.captured;\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.font = 'bold 32px Arial';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText('目标已捕获!', this.canvasSize / 2, this.canvasSize / 2);\n      }\n\n      // 绘制轨迹（如果启用）\n      if (this.showTrails) {\n        this.drawTrails();\n      }\n\n      // 绘制视野和通信范围（如果启用）\n      if (this.showVisionRange || this.showCommunicationRange) {\n        this.drawRanges();\n      }\n\n      // 绘制猎手\n      this.hunters.forEach(function (hunter) {\n        _this3.drawHunter(hunter);\n      });\n\n      // 绘制目标\n      this.targets.forEach(function (target) {\n        _this3.drawAgent(target, 'target');\n      });\n\n      // 更新之前的位置\n      this.updatePreviousPositions();\n      this.previousIsRunning = this.isRunning;\n      this.previousIsCaptured = this.isCaptured;\n    },\n    // 单独绘制猎手，根据角色不同使用不同样式\n    drawHunter: function drawHunter(hunter) {\n      var pos = this.transformPosition(hunter.position);\n\n      // 获取猎手角色和对应的样式\n      var role = hunter.role || 'standard';\n      var style = this.roleStyles[role] || this.roleStyles.standard;\n\n      // 绘制猎手\n      this.ctx.beginPath();\n      this.ctx.arc(pos.x, pos.y, style.size, 0, Math.PI * 2);\n      this.ctx.fillStyle = style.color;\n      this.ctx.fill();\n      this.ctx.strokeStyle = '#fff';\n      this.ctx.lineWidth = 1;\n      this.ctx.stroke();\n\n      // 绘制ID标签\n      this.ctx.font = '10px Arial';\n      this.ctx.fillStyle = '#000';\n      this.ctx.textAlign = 'center';\n      this.ctx.fillText(hunter.id.toString(), pos.x, pos.y + 15);\n\n      // 可选：显示角色名称\n      if (role !== 'standard') {\n        this.ctx.font = '8px Arial';\n        this.ctx.fillStyle = '#333';\n        this.ctx.fillText(role.substring(0, 1).toUpperCase(), pos.x, pos.y - 10);\n      }\n    },\n    // 单独绘制轨迹\n    drawTrails: function drawTrails() {\n      var _this4 = this;\n      // 绘制猎手轨迹\n      this.hunters.forEach(function (hunter) {\n        if (hunter.history && hunter.history.length > 1) {\n          _this4.ctx.beginPath();\n          var startPos = _this4.transformPosition(hunter.history[0]);\n          _this4.ctx.moveTo(startPos.x, startPos.y);\n\n          // 获取猎手角色和对应的样式\n          var role = hunter.role || 'standard';\n          var style = _this4.roleStyles[role] || _this4.roleStyles.standard;\n          for (var i = 1; i < hunter.history.length; i++) {\n            var histPos = _this4.transformPosition(hunter.history[i]);\n            _this4.ctx.lineTo(histPos.x, histPos.y);\n          }\n          _this4.ctx.strokeStyle = style.color;\n          _this4.ctx.lineWidth = 1;\n          _this4.ctx.stroke();\n        }\n      });\n\n      // 绘制目标轨迹\n      this.targets.forEach(function (target) {\n        if (target.history && target.history.length > 1) {\n          _this4.ctx.beginPath();\n          var startPos = _this4.transformPosition(target.history[0]);\n          _this4.ctx.moveTo(startPos.x, startPos.y);\n          for (var i = 1; i < target.history.length; i++) {\n            var histPos = _this4.transformPosition(target.history[i]);\n            _this4.ctx.lineTo(histPos.x, histPos.y);\n          }\n          _this4.ctx.strokeStyle = _this4.colorMap.target;\n          _this4.ctx.lineWidth = 1;\n          _this4.ctx.stroke();\n        }\n      });\n    },\n    // 单独绘制视野和通信范围\n    drawRanges: function drawRanges() {\n      var _this5 = this;\n      // 绘制猎手视野和通信范围\n      this.hunters.forEach(function (hunter) {\n        var pos = _this5.transformPosition(hunter.position);\n\n        // 绘制视野范围\n        if (_this5.showVisionRange) {\n          _this5.ctx.beginPath();\n          _this5.ctx.arc(pos.x, pos.y, hunter.vision_range * _this5.scale, 0, Math.PI * 2);\n          _this5.ctx.fillStyle = _this5.colorMap.vision;\n          _this5.ctx.fill();\n        }\n\n        // 绘制通信范围\n        if (_this5.showCommunicationRange) {\n          _this5.ctx.beginPath();\n          _this5.ctx.arc(pos.x, pos.y, hunter.communication_range * _this5.scale, 0, Math.PI * 2);\n          _this5.ctx.fillStyle = _this5.colorMap.communication;\n          _this5.ctx.fill();\n        }\n\n        // 绘制捕获范围\n        _this5.ctx.beginPath();\n        _this5.ctx.arc(pos.x, pos.y, 10 * _this5.scale, 0, Math.PI * 2); // 捕获范围固定为10\n        _this5.ctx.fillStyle = _this5.colorMap.captureRange;\n        _this5.ctx.fill();\n      });\n\n      // 绘制目标视野范围\n      this.targets.forEach(function (target) {\n        if (_this5.showVisionRange) {\n          var pos = _this5.transformPosition(target.position);\n          _this5.ctx.beginPath();\n          _this5.ctx.arc(pos.x, pos.y, target.vision_range * _this5.scale, 0, Math.PI * 2);\n          _this5.ctx.fillStyle = 'rgba(244, 67, 54, 0.1)'; // 半透明红色\n          _this5.ctx.fill();\n        }\n      });\n    },\n    // 绘制智能体\n    drawAgent: function drawAgent(agent, type) {\n      var pos = this.transformPosition(agent.position);\n\n      // 绘制智能体\n      this.ctx.beginPath();\n      this.ctx.arc(pos.x, pos.y, type === 'hunter' ? 5 : 7, 0, Math.PI * 2);\n      this.ctx.fillStyle = this.colorMap[type];\n      this.ctx.fill();\n      this.ctx.strokeStyle = '#fff';\n      this.ctx.lineWidth = 1;\n      this.ctx.stroke();\n\n      // 绘制ID标签\n      this.ctx.font = '10px Arial';\n      this.ctx.fillStyle = '#000';\n      this.ctx.textAlign = 'center';\n      this.ctx.fillText(agent.id.toString(), pos.x, pos.y + (type === 'hunter' ? 15 : 20));\n    },\n    // 转换坐标\n    transformPosition: function transformPosition(position) {\n      // 将模拟坐标转换为画布坐标\n      return {\n        x: position[0] * this.scale,\n        y: position[1] * this.scale\n      };\n    },\n    // 清除特定区域\n    clearAgentArea: function clearAgentArea(position) {\n      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n      var pos = this.transformPosition(position);\n      this.ctx.clearRect(pos.x - radius, pos.y - radius, radius * 2, radius * 2);\n    }\n  },\n  watch: {\n    hunters: {\n      handler: function handler() {\n        var _this6 = this;\n        // 使用防抖处理，避免频繁重绘\n        if (this.renderTimer) {\n          clearTimeout(this.renderTimer);\n        }\n        this.renderTimer = setTimeout(function () {\n          _this6.drawOptimizedSimulation();\n        }, 50);\n      },\n      deep: true\n    },\n    targets: {\n      handler: function handler() {\n        var _this7 = this;\n        // 使用防抖处理，避免频繁重绘\n        if (this.renderTimer) {\n          clearTimeout(this.renderTimer);\n        }\n        this.renderTimer = setTimeout(function () {\n          _this7.drawOptimizedSimulation();\n        }, 50);\n      },\n      deep: true\n    },\n    // 添加对obstacles的监听\n    obstacles: {\n      handler: function handler() {\n        this.drawSimulation(true); // 强制完全重绘\n      },\n      deep: true\n    },\n    isRunning: function isRunning(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    isCaptured: function isCaptured(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    showTrails: function showTrails(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    showVisionRange: function showVisionRange(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    showCommunicationRange: function showCommunicationRange(newVal, oldVal) {\n      if (newVal !== oldVal) {\n        this.drawSimulation();\n      }\n    },\n    environmentSize: function environmentSize() {\n      this.scale = this.canvasSize / this.environmentSize;\n      this.drawSimulation(true); // 强制完全重绘\n    },\n    // 获取simulation对象\n    '$parent.simulation': {\n      handler: function handler(newVal) {\n        if (newVal) {\n          this.simulation = newVal;\n          this.drawSimulation(true);\n        }\n      },\n      deep: true\n    }\n  }\n};","map":{"version":3,"names":["name","props","hunters","type","Array","required","targets","environmentSize","Number","isRunning","Boolean","isCaptured","showTrails","showVisionRange","showCommunicationRange","obstacles","default","data","canvasSize","canvas","ctx","scale","colorMap","hunter","target","vision","communication","trail","captureRange","captured","obstacle","roleStyles","tracker","color","size","interceptor","coordinator","flanker","standard","previousPositions","renderTimer","lastRenderTime","targetFPS","renderCount","mounted","initCanvas","drawSimulation","window","addEventListener","handleResize","startRenderLoop","beforeDestroy","removeEventListener","stopRenderLoop","clearTimeout","methods","$refs","getContext","updatePreviousPositions","_this","setTimeout","animationFrameId","performance","now","requestAnimationFrame","renderLoop","cancelAnimationFrame","timestamp","elapsed","frameTime","hasPositionsChanged","drawOptimizedSimulation","length","previousIsRunning","previousIsCaptured","threshold","i","prevHunter","Math","abs","position","prevTarget","map","id","_toConsumableArray","_this2","clearRect","drawBackground","strokeStyle","lineWidth","strokeRect","drawObstacles","fillStyle","fillRect","font","textAlign","fillText","drawTrails","drawRanges","forEach","drawHunter","drawAgent","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","pos","transformPosition","radius","gradient","createRadialGradient","x","y","addColorStop","beginPath","arc","PI","fill","stroke","drawObstacleTexture","err","e","f","dotsCount","floor","angle","random","distance","dotX","cos","dotY","sin","dotSize","gridSize","width","height","moveTo","lineTo","_this3","forceFullRedraw","arguments","undefined","role","style","toString","substring","toUpperCase","_this4","history","startPos","histPos","_this5","vision_range","communication_range","agent","clearAgentArea","watch","handler","_this6","deep","_this7","newVal","oldVal","simulation"],"sources":["src/components/SimulationCanvas.vue"],"sourcesContent":["<template>\r\n  <div class=\"simulation-canvas\">\r\n    <canvas \r\n      ref=\"canvas\" \r\n      :width=\"canvasSize\" \r\n      :height=\"canvasSize\" \r\n      class=\"simulation-canvas__area\"\r\n    ></canvas>\r\n  </div>\r\n</template>\r\n  \r\n<script>\r\nexport default {\r\n  name: 'SimulationCanvas',\r\n  props: {\r\n    hunters: {\r\n      type: Array,\r\n      required: true\r\n    },\r\n    targets: {\r\n      type: Array,\r\n      required: true\r\n    },\r\n    environmentSize: {\r\n      type: Number,\r\n      default: 500\r\n    },\r\n    isRunning: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    isCaptured: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    showTrails: {\r\n      type: Boolean,\r\n      default: true\r\n    },\r\n    showVisionRange: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    showCommunicationRange: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    // 新增:障碍物属性\r\n    obstacles: {\r\n      type: Array,\r\n      default: () => []\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      canvasSize: 600,\r\n      canvas: null,\r\n      ctx: null,\r\n      scale: 1,\r\n      colorMap: {\r\n        hunter: '#3f51b5', // 蓝色\r\n        target: '#f44336', // 红色\r\n        vision: 'rgba(63, 81, 181, 0.1)', // 半透明蓝色\r\n        communication: 'rgba(63, 81, 181, 0.05)', // 更透明的蓝色\r\n        trail: 'rgba(63, 81, 181, 0.5)', // 半透明蓝色\r\n        captureRange: 'rgba(76, 175, 80, 0.3)', // 半透明绿色\r\n        captured: 'rgba(244, 67, 54, 0.3)', // 半透明红色\r\n        obstacle: 'rgba(95, 95, 95, 0.7)' // 障碍物颜色\r\n      },\r\n      // 角色样式映射\r\n      roleStyles: {\r\n        tracker: { color: '#4285F4', size: 6 }, // 追踪者\r\n        interceptor: { color: '#EA4335', size: 6 }, // 拦截者\r\n        coordinator: { color: '#FBBC05', size: 7 }, // 协调者\r\n        flanker: { color: '#34A853', size: 6 }, // 侧翼者\r\n        standard: { color: '#3f51b5', size: 5 } // 默认\r\n      },\r\n      // 新增：跟踪之前的位置，用于优化渲染\r\n      previousPositions: {\r\n        hunters: [],\r\n        targets: []\r\n      },\r\n      // 防抖渲染计时器\r\n      renderTimer: null,\r\n      // 帧率控制\r\n      lastRenderTime: 0,\r\n      targetFPS: 30,\r\n      // 渲染计数，用于降低非必要渲染的频率\r\n      renderCount: 0\r\n    }\r\n  },\r\n  mounted() {\r\n    this.initCanvas();\r\n    this.drawSimulation();\r\n    \r\n    // 添加窗口大小变化监听\r\n    window.addEventListener('resize', this.handleResize);\r\n    \r\n    // 使用requestAnimationFrame实现高效渲染循环\r\n    this.startRenderLoop();\r\n  },\r\n  beforeDestroy() {\r\n    // 清理事件监听器\r\n    window.removeEventListener('resize', this.handleResize);\r\n    \r\n    // 停止渲染循环\r\n    this.stopRenderLoop();\r\n    \r\n    // 清理计时器\r\n    if (this.renderTimer) {\r\n      clearTimeout(this.renderTimer);\r\n    }\r\n  },\r\n  methods: {\r\n    // 初始化画布\r\n    initCanvas() {\r\n      this.canvas = this.$refs.canvas;\r\n      this.ctx = this.canvas.getContext('2d');\r\n      this.scale = this.canvasSize / this.environmentSize;\r\n      \r\n      // 初始化previousPositions\r\n      this.updatePreviousPositions();\r\n    },\r\n    \r\n    // 处理窗口大小变化\r\n    handleResize() {\r\n      // 防抖处理\r\n      if (this.renderTimer) {\r\n        clearTimeout(this.renderTimer);\r\n      }\r\n      \r\n      this.renderTimer = setTimeout(() => {\r\n        // 重新计算画布大小（可选，如果需要响应式调整画布大小）\r\n        // this.canvasSize = Math.min(window.innerWidth * 0.7, 600);\r\n        this.scale = this.canvasSize / this.environmentSize;\r\n        this.drawSimulation(true); // 强制完全重绘\r\n      }, 200);\r\n    },\r\n    \r\n    // 启动渲染循环\r\n    startRenderLoop() {\r\n      if (!this.animationFrameId) {\r\n        this.lastRenderTime = performance.now();\r\n        this.animationFrameId = requestAnimationFrame(this.renderLoop);\r\n      }\r\n    },\r\n    \r\n    // 停止渲染循环\r\n    stopRenderLoop() {\r\n      if (this.animationFrameId) {\r\n        cancelAnimationFrame(this.animationFrameId);\r\n        this.animationFrameId = null;\r\n      }\r\n    },\r\n    \r\n    // 渲染循环\r\n    renderLoop(timestamp) {\r\n      // 计算每帧的时间间隔\r\n      const elapsed = timestamp - this.lastRenderTime;\r\n      const frameTime = 1000 / this.targetFPS;\r\n      \r\n      // 如果时间间隔足够，执行渲染\r\n      if (elapsed >= frameTime) {\r\n        this.lastRenderTime = timestamp;\r\n        \r\n        // 检查位置是否有变化，有变化时才渲染\r\n        if (this.hasPositionsChanged() || this.isRunning) {\r\n          this.drawOptimizedSimulation();\r\n          this.updatePreviousPositions();\r\n        }\r\n      }\r\n      \r\n      // 继续循环\r\n      this.animationFrameId = requestAnimationFrame(this.renderLoop);\r\n    },\r\n    \r\n    // 检查位置是否有变化\r\n    hasPositionsChanged() {\r\n      // 优化：快速检查数组长度变化\r\n      if (this.hunters.length !== this.previousPositions.hunters.length ||\r\n          this.targets.length !== this.previousPositions.targets.length) {\r\n        return true;\r\n      }\r\n      \r\n      // 检查运行状态变化\r\n      if (this.isRunning !== this.previousIsRunning ||\r\n          this.isCaptured !== this.previousIsCaptured) {\r\n        this.previousIsRunning = this.isRunning;\r\n        this.previousIsCaptured = this.isCaptured;\r\n        return true;\r\n      }\r\n      \r\n      // 渲染计数，每5帧强制完全重绘一次（避免累积误差）\r\n      this.renderCount++;\r\n      if (this.renderCount >= 5) {\r\n        this.renderCount = 0;\r\n        return true;\r\n      }\r\n      \r\n      // 只有在运行中或首次渲染时，才进行位置变化检查\r\n      if (!this.isRunning && this.previousPositions.hunters.length > 0) {\r\n        return false;\r\n      }\r\n      \r\n      // 智能体位置变化检测\r\n      const threshold = 0.5; // 位置变化阈值\r\n      \r\n      // 检查猎手位置变化\r\n      for (let i = 0; i < this.hunters.length; i++) {\r\n        const hunter = this.hunters[i];\r\n        const prevHunter = this.previousPositions.hunters[i];\r\n        \r\n        if (!prevHunter) return true;\r\n        \r\n        if (Math.abs(hunter.position[0] - prevHunter.position[0]) > threshold ||\r\n            Math.abs(hunter.position[1] - prevHunter.position[1]) > threshold) {\r\n          return true;\r\n        }\r\n      }\r\n      \r\n      // 检查目标位置变化\r\n      for (let i = 0; i < this.targets.length; i++) {\r\n        const target = this.targets[i];\r\n        const prevTarget = this.previousPositions.targets[i];\r\n        \r\n        if (!prevTarget) return true;\r\n        \r\n        if (Math.abs(target.position[0] - prevTarget.position[0]) > threshold ||\r\n            Math.abs(target.position[1] - prevTarget.position[1]) > threshold) {\r\n          return true;\r\n        }\r\n      }\r\n      \r\n      return false;\r\n    },\r\n    \r\n    // 更新之前的位置\r\n    updatePreviousPositions() {\r\n      // 深拷贝位置数据\r\n      this.previousPositions.hunters = this.hunters.map(hunter => ({\r\n        id: hunter.id,\r\n        position: [...hunter.position]\r\n      }));\r\n      \r\n      this.previousPositions.targets = this.targets.map(target => ({\r\n        id: target.id,\r\n        position: [...target.position]\r\n      }));\r\n    },\r\n    \r\n    // 优化的绘制方法\r\n    drawOptimizedSimulation() {\r\n      if (!this.ctx) return;\r\n      \r\n      // 清除画布\r\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\r\n\r\n      this.drawBackground();\r\n      \r\n      // 绘制环境边界\r\n      this.ctx.strokeStyle = '#ccc';\r\n      this.ctx.lineWidth = 2;\r\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\r\n      \r\n      // 绘制障碍物\r\n      this.drawObstacles();\r\n      \r\n      // 绘制捕获状态\r\n      if (this.isCaptured) {\r\n        this.ctx.fillStyle = this.colorMap.captured;\r\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n        this.ctx.font = 'bold 32px Arial';\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.fillText('目标已捕获!', this.canvasSize / 2, this.canvasSize / 2);\r\n      }\r\n      \r\n      // 绘制轨迹（如果启用）\r\n      if (this.showTrails) {\r\n        this.drawTrails();\r\n      }\r\n      \r\n      // 绘制视野和通信范围（如果启用）\r\n      if (this.showVisionRange || this.showCommunicationRange) {\r\n        this.drawRanges();\r\n      }\r\n      \r\n      // 绘制猎手\r\n      this.hunters.forEach(hunter => {\r\n        this.drawHunter(hunter);\r\n      });\r\n      \r\n      // 绘制目标\r\n      this.targets.forEach(target => {\r\n        this.drawAgent(target, 'target');\r\n      });\r\n    },\r\n    \r\n    // 绘制障碍物\r\n    drawObstacles() {\r\n      if (!this.obstacles || !this.obstacles.length) return;\r\n      \r\n      for (const obstacle of this.obstacles) {\r\n        const pos = this.transformPosition(obstacle.position);\r\n        const radius = obstacle.radius * this.scale;\r\n        \r\n        // 创建渐变效果\r\n        const gradient = this.ctx.createRadialGradient(\r\n          pos.x, pos.y, radius * 0.2,\r\n          pos.x, pos.y, radius\r\n        );\r\n        gradient.addColorStop(0, 'rgba(90, 90, 100, 0.9)');\r\n        gradient.addColorStop(0.7, 'rgba(70, 70, 85, 0.85)');\r\n        gradient.addColorStop(1, 'rgba(50, 50, 65, 0.8)');\r\n        \r\n        // 绘制主体\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\r\n        this.ctx.fillStyle = gradient;\r\n        this.ctx.fill();\r\n        \r\n        // 添加边缘光晕效果\r\n        this.ctx.strokeStyle = 'rgba(120, 120, 140, 0.5)';\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.stroke();\r\n        \r\n        // 添加内部纹理\r\n        this.drawObstacleTexture(pos.x, pos.y, radius);\r\n      }\r\n    },\r\n\r\n    drawObstacleTexture(x, y, radius) {\r\n      // 随机生成内部小圆点\r\n      const dotsCount = Math.floor(radius / 4);\r\n      this.ctx.fillStyle = 'rgba(40, 40, 55, 0.5)';\r\n      \r\n      for (let i = 0; i < dotsCount; i++) {\r\n        const angle = Math.random() * Math.PI * 2;\r\n        const distance = Math.random() * radius * 0.8;\r\n        const dotX = x + Math.cos(angle) * distance;\r\n        const dotY = y + Math.sin(angle) * distance;\r\n        const dotSize = Math.random() * 3 + 1;\r\n        \r\n        this.ctx.beginPath();\r\n        this.ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n      }\r\n    },\r\n\r\n    drawBackground() {\r\n      const gridSize = 25 * this.scale;\r\n      const width = this.canvasSize;\r\n      const height = this.canvasSize;\r\n      \r\n      this.ctx.strokeStyle = 'rgba(200, 200, 220, 0.2)';\r\n      this.ctx.lineWidth = 1;\r\n      \r\n      // 绘制网格线\r\n      for (let x = 0; x <= width; x += gridSize) {\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(x, 0);\r\n        this.ctx.lineTo(x, height);\r\n        this.ctx.stroke();\r\n      }\r\n      \r\n      for (let y = 0; y <= height; y += gridSize) {\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(0, y);\r\n        this.ctx.lineTo(width, y);\r\n        this.ctx.stroke();\r\n      }\r\n      \r\n      // 添加坐标轴\r\n      this.ctx.strokeStyle = 'rgba(150, 150, 180, 0.4)';\r\n      this.ctx.lineWidth = 2;\r\n      \r\n      // x轴\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(0, height/2);\r\n      this.ctx.lineTo(width, height/2);\r\n      this.ctx.stroke();\r\n      \r\n      // y轴\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(width/2, 0);\r\n      this.ctx.lineTo(width/2, height);\r\n      this.ctx.stroke();\r\n    },\r\n    \r\n    // 完整重绘方法\r\n    drawSimulation(forceFullRedraw = false) {\r\n      if (!this.ctx) return;\r\n      \r\n      // 如果不需要强制重绘，使用优化版本\r\n      if (!forceFullRedraw && this.previousPositions.hunters.length > 0) {\r\n        return this.drawOptimizedSimulation();\r\n      }\r\n      \r\n      // 清除画布\r\n      this.ctx.clearRect(0, 0, this.canvasSize, this.canvasSize);\r\n\r\n      this.drawBackground();\r\n      \r\n      // 绘制环境边界\r\n      this.ctx.strokeStyle = '#ccc';\r\n      this.ctx.lineWidth = 2;\r\n      this.ctx.strokeRect(0, 0, this.canvasSize, this.canvasSize);\r\n      \r\n      // 绘制障碍物\r\n      this.drawObstacles();\r\n      \r\n      // 绘制捕获状态\r\n      if (this.isCaptured) {\r\n        this.ctx.fillStyle = this.colorMap.captured;\r\n        this.ctx.fillRect(0, 0, this.canvasSize, this.canvasSize);\r\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n        this.ctx.font = 'bold 32px Arial';\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.fillText('目标已捕获!', this.canvasSize / 2, this.canvasSize / 2);\r\n      }\r\n      \r\n      // 绘制轨迹（如果启用）\r\n      if (this.showTrails) {\r\n        this.drawTrails();\r\n      }\r\n      \r\n      // 绘制视野和通信范围（如果启用）\r\n      if (this.showVisionRange || this.showCommunicationRange) {\r\n        this.drawRanges();\r\n      }\r\n      \r\n      // 绘制猎手\r\n      this.hunters.forEach(hunter => {\r\n        this.drawHunter(hunter);\r\n      });\r\n      \r\n      // 绘制目标\r\n      this.targets.forEach(target => {\r\n        this.drawAgent(target, 'target');\r\n      });\r\n      \r\n      // 更新之前的位置\r\n      this.updatePreviousPositions();\r\n      this.previousIsRunning = this.isRunning;\r\n      this.previousIsCaptured = this.isCaptured;\r\n    },\r\n    \r\n    // 单独绘制猎手，根据角色不同使用不同样式\r\n    drawHunter(hunter) {\r\n      const pos = this.transformPosition(hunter.position);\r\n      \r\n      // 获取猎手角色和对应的样式\r\n      const role = hunter.role || 'standard';\r\n      const style = this.roleStyles[role] || this.roleStyles.standard;\r\n      \r\n      // 绘制猎手\r\n      this.ctx.beginPath();\r\n      this.ctx.arc(pos.x, pos.y, style.size, 0, Math.PI * 2);\r\n      this.ctx.fillStyle = style.color;\r\n      this.ctx.fill();\r\n      this.ctx.strokeStyle = '#fff';\r\n      this.ctx.lineWidth = 1;\r\n      this.ctx.stroke();\r\n      \r\n      // 绘制ID标签\r\n      this.ctx.font = '10px Arial';\r\n      this.ctx.fillStyle = '#000';\r\n      this.ctx.textAlign = 'center';\r\n      this.ctx.fillText(hunter.id.toString(), pos.x, pos.y + 15);\r\n      \r\n      // 可选：显示角色名称\r\n      if (role !== 'standard') {\r\n        this.ctx.font = '8px Arial';\r\n        this.ctx.fillStyle = '#333';\r\n        this.ctx.fillText(role.substring(0, 1).toUpperCase(), pos.x, pos.y - 10);\r\n      }\r\n    },\r\n    \r\n    // 单独绘制轨迹\r\n    drawTrails() {\r\n      // 绘制猎手轨迹\r\n      this.hunters.forEach(hunter => {\r\n        if (hunter.history && hunter.history.length > 1) {\r\n          this.ctx.beginPath();\r\n          const startPos = this.transformPosition(hunter.history[0]);\r\n          this.ctx.moveTo(startPos.x, startPos.y);\r\n          \r\n          // 获取猎手角色和对应的样式\r\n          const role = hunter.role || 'standard';\r\n          const style = this.roleStyles[role] || this.roleStyles.standard;\r\n          \r\n          for (let i = 1; i < hunter.history.length; i++) {\r\n            const histPos = this.transformPosition(hunter.history[i]);\r\n            this.ctx.lineTo(histPos.x, histPos.y);\r\n          }\r\n          \r\n          this.ctx.strokeStyle = style.color;\r\n          this.ctx.lineWidth = 1;\r\n          this.ctx.stroke();\r\n        }\r\n      });\r\n      \r\n      // 绘制目标轨迹\r\n      this.targets.forEach(target => {\r\n        if (target.history && target.history.length > 1) {\r\n          this.ctx.beginPath();\r\n          const startPos = this.transformPosition(target.history[0]);\r\n          this.ctx.moveTo(startPos.x, startPos.y);\r\n          \r\n          for (let i = 1; i < target.history.length; i++) {\r\n            const histPos = this.transformPosition(target.history[i]);\r\n            this.ctx.lineTo(histPos.x, histPos.y);\r\n          }\r\n          \r\n          this.ctx.strokeStyle = this.colorMap.target;\r\n          this.ctx.lineWidth = 1;\r\n          this.ctx.stroke();\r\n        }\r\n      });\r\n    },\r\n    \r\n    // 单独绘制视野和通信范围\r\n    drawRanges() {\r\n      // 绘制猎手视野和通信范围\r\n      this.hunters.forEach(hunter => {\r\n        const pos = this.transformPosition(hunter.position);\r\n        \r\n        // 绘制视野范围\r\n        if (this.showVisionRange) {\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, hunter.vision_range * this.scale, 0, Math.PI * 2);\r\n          this.ctx.fillStyle = this.colorMap.vision;\r\n          this.ctx.fill();\r\n        }\r\n        \r\n        // 绘制通信范围\r\n        if (this.showCommunicationRange) {\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, hunter.communication_range * this.scale, 0, Math.PI * 2);\r\n          this.ctx.fillStyle = this.colorMap.communication;\r\n          this.ctx.fill();\r\n        }\r\n        \r\n        // 绘制捕获范围\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(pos.x, pos.y, 10 * this.scale, 0, Math.PI * 2); // 捕获范围固定为10\r\n        this.ctx.fillStyle = this.colorMap.captureRange;\r\n        this.ctx.fill();\r\n      });\r\n      \r\n      // 绘制目标视野范围\r\n      this.targets.forEach(target => {\r\n        if (this.showVisionRange) {\r\n          const pos = this.transformPosition(target.position);\r\n          this.ctx.beginPath();\r\n          this.ctx.arc(pos.x, pos.y, target.vision_range * this.scale, 0, Math.PI * 2);\r\n          this.ctx.fillStyle = 'rgba(244, 67, 54, 0.1)'; // 半透明红色\r\n          this.ctx.fill();\r\n        }\r\n      });\r\n    },\r\n    \r\n    // 绘制智能体\r\n    drawAgent(agent, type) {\r\n      const pos = this.transformPosition(agent.position);\r\n      \r\n      // 绘制智能体\r\n      this.ctx.beginPath();\r\n      this.ctx.arc(pos.x, pos.y, type === 'hunter' ? 5 : 7, 0, Math.PI * 2);\r\n      this.ctx.fillStyle = this.colorMap[type];\r\n      this.ctx.fill();\r\n      this.ctx.strokeStyle = '#fff';\r\n      this.ctx.lineWidth = 1;\r\n      this.ctx.stroke();\r\n      \r\n      // 绘制ID标签\r\n      this.ctx.font = '10px Arial';\r\n      this.ctx.fillStyle = '#000';\r\n      this.ctx.textAlign = 'center';\r\n      this.ctx.fillText(agent.id.toString(), pos.x, pos.y + (type === 'hunter' ? 15 : 20));\r\n    },\r\n    \r\n    // 转换坐标\r\n    transformPosition(position) {\r\n      // 将模拟坐标转换为画布坐标\r\n      return {\r\n        x: position[0] * this.scale,\r\n        y: position[1] * this.scale\r\n      }\r\n    },\r\n    \r\n    // 清除特定区域\r\n    clearAgentArea(position, radius = 20) {\r\n      const pos = this.transformPosition(position);\r\n      this.ctx.clearRect(pos.x - radius, pos.y - radius, radius * 2, radius * 2);\r\n    }\r\n  },\r\n  watch: {\r\n    hunters: {\r\n      handler() {\r\n        // 使用防抖处理，避免频繁重绘\r\n        if (this.renderTimer) {\r\n          clearTimeout(this.renderTimer);\r\n        }\r\n        this.renderTimer = setTimeout(() => {\r\n          this.drawOptimizedSimulation();\r\n        }, 50);\r\n      },\r\n      deep: true\r\n    },\r\n    targets: {\r\n      handler() {\r\n        // 使用防抖处理，避免频繁重绘\r\n        if (this.renderTimer) {\r\n          clearTimeout(this.renderTimer);\r\n        }\r\n        this.renderTimer = setTimeout(() => {\r\n          this.drawOptimizedSimulation();\r\n        }, 50);\r\n      },\r\n      deep: true\r\n    },\r\n    // 添加对obstacles的监听\r\n    obstacles: {\r\n      handler() {\r\n        this.drawSimulation(true); // 强制完全重绘\r\n      },\r\n      deep: true\r\n    },\r\n    isRunning(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    isCaptured(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    showTrails(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    showVisionRange(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    showCommunicationRange(newVal, oldVal) {\r\n      if (newVal !== oldVal) {\r\n        this.drawSimulation();\r\n      }\r\n    },\r\n    environmentSize() {\r\n      this.scale = this.canvasSize / this.environmentSize;\r\n      this.drawSimulation(true); // 强制完全重绘\r\n    },\r\n    // 获取simulation对象\r\n    '$parent.simulation': {\r\n      handler(newVal) {\r\n        if (newVal) {\r\n          this.simulation = newVal;\r\n          this.drawSimulation(true);\r\n        }\r\n      },\r\n      deep: true\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.simulation-canvas {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  margin: 16px 0; /* 增加上下边距 */\r\n}\r\n\r\n.simulation-canvas-card {\r\n  border-radius: 8px;\r\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\r\n  overflow: hidden;\r\n  background: linear-gradient(to bottom, #fafbff, #f0f4f8);\r\n}\r\n\r\n.simulation-canvas__area {\r\n  border: none;\r\n  background-color: #fcfcff;\r\n}\r\n\r\n.control-panel {\r\n  border-radius: 8px;\r\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);\r\n  overflow: hidden;\r\n}\r\n\r\n.info-title, .chart-title, .panel-title {\r\n  background: linear-gradient(to right, #3949AB, #5C6BC0);\r\n  color: white;\r\n  padding: 10px 16px !important;\r\n}\r\n\r\n\r\n.simulation-canvas__controls {\r\n  display: flex;\r\n  gap: 8px;\r\n}\r\n\r\n.simulation-canvas__controls .v-btn {\r\n  height: 32px !important;\r\n  min-width: 60px !important;\r\n  font-size: 0.8rem !important;\r\n  padding: 0 8px !important;\r\n}\r\n\r\n.simulation-canvas__controls .v-btn .v-icon {\r\n  font-size: 18px !important;\r\n}\r\n</style>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}